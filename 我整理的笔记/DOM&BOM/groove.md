	目的：整理自己所学知识点，系统性归纳，辅助加深记忆。

方式：在掘金写文章（知乎、CSDN、简书都能上？）





按照标签划分自己整理的知识点：

CSS

HTML

JavaScript



**先找一下自己已经写过的文章，做一个摘要和整理，然后再考虑写文章**

Winter重学前端，是重心，根据Winter 的重学前端来完成整体的文章撰写。

每看完一个章节，就写下一篇文章。

案头参考：《你不知道的JavaScript》，《JavaScript权威指南》，《JavaScript 高级程序设计》(备选)。





### JavaScript 知识架构图

核心思想：

-   编程语言的一般规律：用规定的词法和语法，表达出规定的语义，最后操作运行时。
-   运行时划分为数据结构和操作系统。
    -   程序 = 算法 +数据结构
        -   数据结构：类型 + 实例。
            -   类型就是 7 种基本类型和 7 种语言类型。实例就是 JavaScript 的内置对象。
        -   算法：JavaScript对于程序具体执行过程的规则。



### 4月15日

-   类型、强制类型转换、值、封装对象包装/拆装，太繁琐。先跳过吧。复习到这里再看。先把大头复习了，也就说 你不知道的 JavaScript 上册：
-   先看完 winter 的专栏，然后有一个整体的概念，然后再把重点拷问的内容复习整理了，看winter可以完善知识架构图，但是没必要去搞那么细。
    -   作用域、闭包、this、指针、promise 这些才是重点，必须会考的，先抓重点复习，千万不能掉入大而全的陷阱。

另一个思路：

-   先看JavaScript权威指南，通过看完winter 内容，然后对比 这里面的内容。整理一份简单的知识清单，后期把你不知道的Js的知识点放进去。

















如果我们想创造两个相等的`Symbol`变量，可以使用`Symbol.for(key)`。

-   使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。



==============

基本类型和包装类型的主要区别就是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。

-   `123 === new Number(123)  // false`

================

每一个引用类型都有`toString`方法，默认情况下，`toString()`方法被每个`Object`对象继承。如果此方法在自定义对象中未被覆盖，`toString()` 返回 `"[object type]"`，其中`type`是对象的类型。

================

去年就因为把强弱类型和静态语言动态语言的概念搞混了，最后一面直接挂了

================

`lref`是等号左边表达式的计算结果，
`lval`是`lref Getvalue`之后的结果，也就是左值，
`rref`是等号右边表达式的计算结果，
`rval`是`rref Getvalue`之后的结果，也就是右值。
引用左值和引用右值是C++中的概念？
我查了下，感觉和这里的概念不太一样，不过可以类比一下。
因为js中的引用类型和C++中不太一样，所以说`lref`和`rref`也有可能并不是引用类型。

================

Symbol 在对象系统中的广泛运用，构成了一类接口形式。利用 Symbol 可以访问、修改更多的API接口。

-   Symbol、Proxy & Reflect、属性描述符 defineProperty 从不同的方式修改了系统默认的行为，后期可以具体分析一下各自的区别和特点。

================





类型 值 类型判断 类型转换



1.  先介绍类型
2.  再简单介绍值的概念
3.  如何判断一个类型
4.  什么是类型转换，如何实现类型转换。





=======================





# 值

## 1 数组

JavaScript 的数组可以容纳任何类型的值，String、Number、Object、其他数组。

JavaScript 的数字不需要在声明时设定大小，数组的大小可随时变化。



Bug：

-   数组是一个对象。所以可以在某个数组中创建属性。但创建的属性不会被 数组的 length 属性统计在内。

-   `a["13"]`，字符串被强制类型转换为数字 13，所以该访问可以成功。

-   创建稀疏数组，空白单元会返回 `undefined`。

    ```js
    let a = [];
    a[3] = 3;
    console.log(a)  // 浏览器输出：(4) [空 × 3, 3]
    // 事实上是：[undefined, undefined, undefined, 3]
    ```





### 字符串

数字的自动拆箱

```js
function foo(x) {
  x = x + 1;  // 此处经历了自动拆箱
  console.log(x);   // 3
}

let a = 2;
let b = new Number(a);

foo(b);
console.log(b);  // 2
```

需要知道的知识：

-   number 是基本数据类型，值是不可变的。

-   number 经过包装函数 Number 包装为一个对象后。其值被写入了这个包装对象的 `[[PrimitiveValue]]` 原始值中。该值不可被修改。
-   在 foo函数中，`x = x + 1` 经历了自动拆箱，所以此时 x 已经从 Number 包装对象转化为了普通数字。但外部作用域中的变量 b 仍然指向 Number 包装对象。











