# Object API

统计常用的 Object API，共计 19 个



### Object.is()

判断两个值是否为一同个值。更多用法见 **类型章节**。

```js
Object.is(10, 10) // true
```



## 1 对象的定义与继承

### Object.assign()

对象的合并：用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。



### Object.create()

对象的创建：创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`。 

- `Object.create(null)`，会创建一个没有原型链的对象。
- `Object.create(null, {....})`，可以传入其他对象，来增强新创建的对象。



### Object.defineProperty()

定义、修改对象的一个属性。

```js
Object.defineProperty(obj, prop, descriptor) // 对象、属性名、属性描述符

// example
Object.defineProperty(obj, "key", {
  enumerable: false,
  configurable: false,
  writable: false,
  value: "static"
});
```



### Object.defineProperties()

定义、修改对象的多个属性

```js
Object.defineProperties(obj, props) 

// example
let obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
});
```



### Object.getOwnPropertyDescriptor()

获得目标对象上一个自有属性对应的属性描述符。

```js
let person = {
    name: "Moxy"
}
let descriptor = Object.getOwnPropertyDescriptor(person, "name")
descriptor
// {value: 'Moxy', writable: true, enumerable: true, configurable: true}
```





### Object.getPrototypeOf()

获得指定对象的原型（内部`[[Prototype]]`属性的值）。

- `Object.getPrototypeOf(obj)` 就相当于 `obj,__proto__` 的标准版

```js
// example 1
function Father() {}
function Son() {}
Son.prototype = Object.create(Father.prototype)

Object.getPrototypeOf(Son.prototype) === Father.prototype // true
Son.prototype.__proto__ === Father.prototype // true

// example 2
let father = {}
let son = Object.create(father)

Object.getPrototypeOf(son) === father // true
son.__proto__ === father // true
```



### Object.setPrototypeOf()

把目标对象的原型（即, 内部[[Prototype]]属性）链接到另一个对象上。

- 不推荐使用此方法。而更推荐使用 `Object.create()`，性能更好。

```js
function Father() {}

function Son() {}
Object.setPrototypeOf(Son.prototype, Father.prototype)
// 效果相当于：
// Son.prototype = Object.create(Father.prototype)

Object.getPrototypeOf(Son.prototype) === Father.prototype // true
Son.prototype.__proto__ === Father.prototype // true
```



## 2 对象属性的遍历

### Object.keys()

### Object.values()

`keys` 返回一个数组，其成员是目标对象 **自有的**、**可枚举的** 属性名。

`values` 返回一个数组，其成员是目标对象 **自有的**、**可枚举的** 属性值。

- 数组中排列顺序和正常循环遍历时的顺序一致。

```js
let obj = {
    green: "Happy",
    blue: "Smile",
    red: "hot"
}

console.log(Object.keys(obj))   // (3) ['green', 'blue', 'red']
console.log(Object.values(obj)) // (3) ['Happy', 'Smile', 'hot']
```



### Object.entries()

返回一个数组，其元素一组组的键值对，是在 `object` **上自有的**、**可枚举的**属性和属性值。

- 返回了一个可迭代的对象。

```js
let obj = {
    green: "Happy",
    blue: "Smile",
    red: "hot"
}
for (let [key, value] of Object.entries(obj)) {
    console.log(`${key}: ${value}`);
}
// green: Happy
// blue: Smile
// red: hot
```



### Object.getOwnPropertyNames()

获得目标对象的所有 **自有的** 属性名。

- 包括不可枚举属性
- 不包括 `Symbol` 值作为名称的属性
- 返回一个数组。

```js
let person = {
    name: "Moxy",
    age: "18",
    class: "3"
}

let res = Object.getOwnPropertyNames(person)
console.log(res) // (3) ['name', 'age', 'class']
```



### Object.getOwnPropertySymbols()

获得目标 **自有的** 所有 Symbol 属性的数组。

```js
let uid = Symbol('uid');
let x = Symbol('x');
let person = {
    name: "Moxy",
    age: "18",
    class: "3",
    [uid]: 001,
    [x]: "x"
}

let res = Object.getOwnPropertySymbols(person)
console.log(res) // (2) [Symbol(uid), Symbol(x)]
```



## 3 对象的不变性

### Object.preventExtensions()

- 令对象禁止扩展

### Object.seal()

- 密封一个对象

### Object.freeze()

- 冻结一个对象

### Object.isExtensible()

- 判断一个对象是否是可扩展，如果不可扩展，则返回 `false`。

### Object.isSealed()

- 判断一个对象是否已密封，如果已密封，则返回 `true`。

### Object.isFrozen()

- 判断一个对象是否已冻结，如果已冻结，则返回 `true`。

