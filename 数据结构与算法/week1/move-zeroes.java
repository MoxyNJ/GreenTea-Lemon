package week2;
/*
 题解思路：
 loop，i为loop遍历的下标。每当遇到0元素，就需要挪动到最后。那反过来说，遇到一个非零元素，如果数列前面有0元素，这个非零元素就需要往前挪。
 j 就解决了：每遍历到一个非零元素，就调整这个元素在原数组中的位置。j实现的最终效果，是在原数组的位置，从头开始，依次把遍历到非零元素写入、覆盖原数据。
 (在 i loop完后，i和j的下标之差，就是0元素的个数，把这些位置填入0即可)这段可以优化：
    每次i遇到了一个不为零的元素，进行两个操作：1. 在j的位置上，写入这个数；2.在i的位置上，写入0。这样，i循环完后，所有的位置就都进行了正确内容的写入。
*/

class Solution {
    public void moveZeroes(int[] nums) {
        int j = 0;
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] != 0) {
                nums[j] = nums[i];
                if(i != j)
                    nums[i] = 0;
                j++;
            }
        }
    }
}
