#  组件化

# Part 1

# 1 组件基础 ｜ 组件的基本知识

前端最热门的两个话题：

- 组件化：主要目标就是复用。
- 架构模式：MVC、MVVC。关心前端和数据逻辑层之间的交互规则。

组件既是对象，又是模块。组件是一个与UI强相关的概念。可以以树形结构来组合。

## 1.1 组件 & 对象

### 对象

对象的三大要素：

- Properties 属性
- Methods 方法
- Inherit 继承关系（Javascript在运行时，原型继承）

### 组件

- Properties 属性
- Methods 方法
- Inherit 继承关系
- Attribute 特性
- Config & State 配置（预传参数） & 状态（随着人的操作/方法的调用，会发生变化）
- Event 事件机制（组件往外传递东西）
- Lifecycle 生命周期
- Children 树形结构的必要性



![image-20201130211032351](source/image-20201130211032351.png)

结构：左边是用户、中间是组件（或者说开发组件的程序员）、右边是程序员（或者说使用组件的程序员）

- 用户操作组件，会影响组件的 State状态（界面操作、输入文本），相应的，Children也可能会收到影响。

- 程序员通过 Attribute 去更改组件的特征 / 特性。
  - attribute：是声明型语言，markup language。
  - Property：和对象的Property的概念一致。直接设置组件上的属性。
  - attribute 和 Property 有时候统一，有时候不一样，这要看设计者的思路。
  - Property 在 Js 中，有 Get 和 Set 两个方法获取属性值，这一点上和 Method 有重合的功能。所以，根据不一样的设计者思路，有可能 Method 和 Property 也会是一个统一的概念。
- Event 的箭头是反过来的。可以看到，是开发组件的程序员向使用组件的程序员传递信息。

## 1.2 Attribute & Property

**Attribute**，强调描述性。描述一个对象的具体细节。

**Property**，强调从属关系。描述一个对象的是某个对象的子对象 / 父对象，体现从属关系。



### 举例：

在HTML中，property 和 attribute 就是不相同的概念：

```jsx
<!-- attribute -->
<my-component attribute="v" />

myComponent.getAttribute("a");
myComponent.setAttribute("a", "value");

<!-- property -->
myComponent.a = "value";
```



### 举例1

早年 JavaScript 中，class 是关键字，不允许 class 做属性名。现在允许了，HTML为了规避这一问题，区分了 attribute 和 property，做了如下改动：

- attribute：class，HTML依然不支持 class，只支持 className。
- property：className

```html
<div class="cls1 cls2"></div>

<script>
var div = document.getElementsByTagName('div');

// console 键入：
// property方法获取
div[0].className    // "cls1 cls2"
div[0].class        // undefined。property的命名，不是class，而是className。

// attribute方法获取
div[0].getAttribute("class");  // "cls1 cls2"
div[0].getAttribute("className");  // null
</script>
```



### 举例2

有些时候，attribute 和 property 之间的类型也不同。

- Attribute是一个字符串
- Proporty是一个字符串语义化的一个对象。

比如 style 属性在HTML中，attribute style 是一个字符串。可以用 getAttribute 和 setAttribute 修改 属性值。但是，用 proporty style 是一个 K-V 结构的集合，用来修改属性值更方便。所以，用 proporty 更方便。

```html
<div class="cls1 cls2" style="color: blue"></div>

<script>
var div = document.getElementsByTagName('div');
// console 键入：
div[0].style   //  一个对象。CSSStyleDeclaration {...}
div[0].getAttribute("style")     // "color: blue"
</script>
```



### 举例3

href 属性，attribute 和 property 的意思差不多。但是 Proporty是一个经过 resolve 过的 url。而 attribute 就是代码中写啥是啥。虽然两者语义非常相似，但是还是有区别。

```html
<a href="//m.taobao.com"></div>
<script>
    var a = document.getElementsByTagName("a");
    a[0].href                   // "file://m.taobao.com/"，这个URL是resolve的结果
    a[0].getAttribute("href")   // "//m.taobao.com"，跟HTML代码中完全一致
</script>
```



### 举例4

input 属性，value 是值是不相同的：

- attribute：value 是一个默认值。不论是用户在页面中修改 input 内容，还是程序员用代码给 proporty 赋值，它的 attribute 都是不会变的。
- property：在网页显示上，会优先显示 property 的值。
- attribute 和 property 可以分别定义，分别获取。两者是不等效的。

```html
<input value="cute" />
<script>
    var input = document.getElementsByTagName("input")[0];

    input.value     //"cute"
		input.getAttribute("value")     //"cute"
		input.value = "hello"           // 此时，value属性已经设置，则attribute不变，property变化。
  																	// 网页显示，会显示 property的 hello。
		input.value         //"hello"。property的值已经改变
		input.getAttribute("value")     //"cute"。attribute的值没有改变。
  
  	input.setAttribute("value", "world")	// 如果修改了attribute值
		input.value					//"hello"					// property的值不会改变。网页依然显示 hello
		input.getAttribute("value")						//"world" attribute被修改了。
</script>
```



## 1.3 如何设计组件状态

#### 四个场景

- Markup set：用标签去设置，静态声明语言。
- JS set：用 JavaScript 代码去设置。
- JS Change：用 JavaScript 去改变。
- User Input Change：由用户去改变。

![image-20201201082158071](source/image-20201201082158071.png)

State：状态通常是由用户去改变的，组件的设计者不会把改变状态的功能，设计给程序员。

config：是一个一次性的结果。只有在组件构造的时候会触发。是不可更改的。通常会把 config 留给全局。



## 1.4 Lifecycle

生命周期：created + destroyed

![image-20201201083104433](source/image-20201201083104433.png)

1. mount：组件挂到屏幕上。一个组件，在创造后，会被屏幕显示出来。即放到了 DOM 树上。
   - umount：组件从屏幕上卸下。
   - mount 和 unmount 有时会反复发生，一个循环。
2. JS change / set：组件的使用者（程序员）
3. User Input：终端用户
   - 程序员或终端用户在点击/修改组件时，触发组件更新。进入一个循环。



## 1.5 Children

Content 型 & Template 型

- Content型：有几个 Children，最终就能显示几个 Children
- Template型：Children充当了一个模板的作用。

例如，设计一个 list，Template型 Children 构造了一个 list 的结构。但是，这个 list 在真实的使用时，Children 的具体数目是不确定的。在 list 使用时，会传入一个 data，根据数据项的个数，构造相应长度的 list。如果接受了一个100项的数据，就会有100个实际的 Children，模板会复制 100份。 

```html
<!-- Template型 -->
<my-button><img src="{{icon}}"/>{{title}}</my-button>

<my-list>
	<li><img src="{{icon}}"/>{{title}}</li>
</my-list>
```



# 2 为组件添加JSX语法 ｜ 组件的基本知识

1. 在终端中：

   1. `mkdir jsx` 创建文件夹
   2. `cd jsx`
   3. `npm init` 然后所有选项不去更改，npm就创建好了。
   4. `npm install -g webpack webpack-cli` 用npm 全局安装 webpack包
      1. `npm install -g npm` npm更新
   5. `npm install -save-dev webpack babel-loader`安装 babel-loader(安装到本地目录中), babes plugin
      - 四个包的功能：
        - webpack：把一个普通的 JavaScript 文件，能够和不同 import 或 requre 一起打包。
        - babel：把一个新版本的Js编译成一个老版本的Js，可以让文件支持更多的老版本浏览器。

2. 打开 vs code：

   1. 在jsx文件夹中，创建 webpack.config.js。
      1. 设置好 entry，指向 main.js
   2. 创建 main.js。可以先定义一个简单的代码。
   3. 打开调试 ==> 创建 launch.json ==> 打开 终端 ==> 键入：webpack
   4. 可以看到，此时生成了 dist 文件夹 ==> 里面的 main.js 进过了加工。

3. 继续在 vs code中：

   1. 安装 babel，终端键入：`npm install --save-dev @babel/core @babel/preset-env`

   2. 在 webpack.config.js中，加入 module，引入 babel。
   3. 测试，终端键入：`webpack` 显示编译成功。
   4. 再看 dist/main.js中，可以看到之前到 for...of 语句，已经被编译为基本 for 循环，适配低版本的 JavaScript 代码了。  

4. 在 web pack.config.js中，添加 `mode:"development"`，开发者模式。

   1. 此时，再看 dist/main.js 中，可以看到代码不再压缩，可以直接调试生成的代码本身。

5. 在 main.js 中，尝试输入一些 JSX代码，之后直接终端 `webpack`，发现会报错。这是因为没有引入 JSX。

   1. 终端键入：`npm install --save-dev @babel/plugin-transform-react-jsx`
   2. wabpack.config.js 中，配置上该包。
      1. 测试，终端：`webpack`。显示成功。JSX成功引入。
      2. 原先在 main.js 中测试的JSX代码：`let a = </div>`，在 dist/main.js 中，转义为`React.createElement(\"div\", null);`。



# Part 2

# 1. 从无到有的实现一个轮播图组件：

对JSX插件（web pack.config.js）进行配置修改：

给 plugins 添加配置：

```JSX
plugins: ["@babel/plugin-transform-react-jsx"],
  
// 修改为：
plugins: [["@babel/plugin-transform-react-jsx",{pragma:"createElement"}]], 
```

可以看到，在修改配置之前，webpack 对 main.js代码的JSX文档改写，从 `<div/>` 改为：`React.createElement(\"div\", null);`。对配置修改之后，重新在终端执行 webpack，发现 main.js 改写为：`createElement(\"div\", null);`。

这样做，使 JSX 的运行和 react 没有任何关系了。



### 测试1

定义一个 div元素，其中嵌套了 3 个 children：span元素。

1. 如果在 div元素中，定义了属性值，那么第二个参数位置就是一个 K-V 对象，保存着各个属性值；反之，如果没有任何属性定义，那第二个参数就会传递 `null`。

2. 可以看到，在HTML页面，最终显示的效果递归调用 createElement()。所有的子元素（span）被作为参数，传递给了第一个 createElement方法。

```jsx
// main.js 中输入：
function createElement(){
    return;
}

let a = <div id="a">
        <span></span>
        <span></span>
        <span></span>
    </div>;    


// 最终在HTML是这样显示的：
function createElement(){
    return;
}

var a = createElement("div", {
  id: "a"
}, 
	createElement("span", null), 
	createElement("span", null),
	createElement("span", null),
);
```



### 测试2

由测试1可以知道，事实上createElement存在一个参数列表，那么，在定义的时候不妨都添加上：

​	`function createElement(type, attributes, ...children) { ... }`

把 createElement方法进行丰富：

- type 是要创建的元素，直接创建出来；
- attributes 是一个K-V对象，利用 for in  和 for of 把属性值添加到 type 创建的元素上；
- ...children 是一个可变长数组，保存了所有要添加的子元素，直接添加到 type 创建的元素上。

这样，main.js 的代码变成了：

```jsx
function createElement(type, attributes, ...children){
    let element = document.createElement(type);
    // in is key, of is value 
    for(let name in attributes) {
        element.setAttribute(name, attributes[name]);
    }
    for(let child of children) {
        element.appendChild(child);
    }
    return element;
}

let a = <div id="a">
        <span></span>
        <span></span>
        <span></span>
    </div>;

document.body.appendChild(a);
```

不要忘记，在main.html 中，添加一个 body 元素。如果不添加， script 是在生成 body之前创建，会出现问题：

```html
// main.html
<body></body>
<script src="./main.js"></script>
```

进行 webpack后，打开 main.html。可以看到现在 div可以正确被创建，同时子元素也正确可以被添加：

![image-20201201204913014](source/image-20201201204913014.png)

### 测试3

现在，实现的功能有：

- 正确的创建一个元素，element。
- 给 element 添加多个属性 attributes。
- 给 element 添加多个子元素 children。

问题：如果要给元素添加文本节点，需要解决哪些问题呢？

```JSX
let a = <div id="a">
      <span></span>
      Hello world!
    </div>;
```

用 webpack打包后。浏览器打开 main.html，可以看到 main.js 中是这样显示的：

```JSX
// source栏中，top/jsx/./main.js
function createElement(type, attributes) {
  var element = document.createElement(type); // in is key, of is value 

  for (var name in attributes) {
    element.setAttribute(name, attributes[name]);
  }

  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  for (var _i = 0, _children = children; _i < _children.length; _i++) {
    var child = _children[_i];
    element.appendChild(child);
  }

  return element;
}

var a = createElement("div", {
  id: "a"
}, createElement("span", null), "Hello World!");
document.body.appendChild(a);

```

可以看到，如果在元素中添加的不是子元素，而是文本节点。那传递的就是一个字符串。发现了这个情况，做以下改动：

- 判断 children 的成员类型，如果是 string，则创建一个 TextNode，把字符串添加到这个节点中。

```jsx
function createElement(type, attributes, ...children){
    let element = document.createElement(type);
    // in is key，of is value 
    for(let name in attributes) {
        element.setAttribute(name, attributes[name]);
    }
    for(let child of children) {
        if(typeof child === "string") {
            child = document.createTextNode(child);
        }
        element.appendChild(child);
    }
    return element;
}

let a = <div id="a">
        <span></span>
        Hello World!
    </div>;

document.body.appendChild(a);
```

成功！具备一定的 DOM 操作。



### 测试4

如果在定义时，div 是大写的 "Div"

```jsx
let a = <Div id="a">
        <span></span>
        Hello World!
    </Div>;
```

在变异后的 main.js 中看到，这里的 Div 没有加引号了，没有被正确识别。被当成了一个 class 关键字。

```jsx
var a = createElement(Div, {
  id: "a"
}, createElement("span", null, "a"));
document.body.appendChild(a);
```

需要做一个区分：div 和 Div。以下是基本的设计思路。

1. 定义一个 class Div

2. 在createElement中，对 type 做一个这样的大体判断：
   1. 如果是 Div，则传入的是一个 class Div，`element = new type`，把这个 Div 实例化，传递给 element。
   2. 如果是 div 则按照之前的代码，完成 element 的创建。

3. 下面来解决 class Div 中的内容：
   1. 利用 `mountTo()`方法，完成 div 的正确创建。
   2. 还需要完成：
      1. setAttribute() 方法，属性的正确添加；
      2. appendChild() 方法，子元素的正确添加；
      3. 这时，需要一个 constructor() 方法，确保 `this.root` 属性可以被其他方法使用。

4. 测试 webpack，可以看到，Div 可以正常的被创建了。用 mountTo() 方法，而不是appendChild() 方法。这里有个问题，普通的 “div”，是没有 mountTo() 这样的方法的，是利用 createElement 方法来完成创建，而不是利用 new Div。所以，这里要把 createElement() 方法，替换成 new ElementWrapper。重新定义一个 ElementWrapper 类。
   1. ElementWrapper 类，和 Div 类一样：
      - constructor()，把 this.root 作为变量。
      - setAttribute() 方法。实现了属性的添加；
      - appendChild() 方法。实现了子元素的添加；
      - mountTo() 方法。实现了元素在DOM上指定位置的添加。
   2. 需要把所有的 appendChild 都改为 mountTo。

5. Text Node 也需要按照上文进行 Wrapper，结构大同小异。
   1. 需要注意的是，文本节点不需要 setAttribute() 和 appendChild() 功能，留空即可。



最后：“Div” 不是真的定义一个无聊的 “div” 另一个写法，而是为了引申出一个自定义组件，比如 Carousel（旋转木马，轮播图）。有了` class Carousel`  我们可以在自己的组件中，自定义想要的结构和功能。

最终代码：



```jsx
/////////////////////    main.js     //////////////////////////
function createElement(type, attributes, ...children){
    let element;
    if(typeof type === "string"){
        element = new ElementWrapper(type);
    } else {
        element = new type;
    }
    // in is key，of is value 
    for(let name in attributes) {
        element.setAttribute(name, attributes[name]);
    }
    for(let child of children) {
        if(typeof child === "string") {
            child = new TextWrapper(child);
        }
        element.appendChild(child);
    }
    return element;
}

class ElementWrapper {
    constructor(type){
        this.root = document.createElement(type);
    }
    setAttribute(name, value){
        this.root.setAttribute(name, value);

    }
    appendChild(child){
        // this.root.appendChild(child);
        child.mountTo(this.root);
    }
    mountTo(parent) {
        parent.appendChild(this.root);
    }
}

class TextWrapper {
    constructor(content){
        this.root = document.createTextNode(content);
    }
    setAttribute(){
    }
    appendChild(){
    }
    mountTo(parent) {
        parent.appendChild(this.root);
    }
}

class Div {
    constructor(){
        this.root = document.createElement("div");
    }
    setAttribute(name, value){
        this.root.setAttribute(name, value);

    }
    appendChild(child){
        // this.root.appendChild(child);
        child.mountTo(this.root);
    }
    mountTo(parent) {
        parent.appendChild(this.root);
    }
}

let a = <Div id="a">
        <span>a</span>
        <span>b</span>
        <span>c</span>
        <div>Hello World!</div>
    </Div>;

// document.body.appendChild(a);
// 反向插入:
a.mountTo(document.body);
```

![image-20201201222912512](source/image-20201201222912512.png)



# 2 轮播组件化

## 2.1  轮播组件（1）

实现一个 Carousel组件：

1. 把之前实现的基本功能，全部都移动到一个新文件中 framework.js ：
   - function createElement(type, attributes, ...children)，function 需要在前面添加 export。
   - class ElementWrapper
   - class TextWrapper
   - class Div（这个弃用，当初只是为了做测试用）
2. 在 framework.js 中，发现 ElementWrapper 和 TextWrapper 中，`setAttribute()`, `appendChild()`, `mountTo()`，是重复的。所以把他们提取出来，新建一个 class Component， 放入其中。
   1. class Component 定义一个 `constructor()`，来获取 this.root；
   2. 另 ElementWrapper 和 TextWrapper 继承 Component；

3. main.js 中：
   1. 引入 Component，createElement 
   2. 加入 webpack-dev 方便 debug：
      1. 安装：`npm install webpack-dev-server --save-dev`
      2. 安装：`npm install --save-dev webpack-cli `
      3. 我目前的版本：
         1. webpack-cli 4.2.0
         2. webpack 5.9.0
         3. webpack-dev-server@3.11.0
      4. 此处我折腾了数次，引用评论区 @Corazon 的评论：
         1. 如果你电脑全局没有装 webpack-dev-server
            你直接使用 webpack-dev-server 命令会报错 command not found: webpack-dev-server
            需要使用 node_modules/.bin/webpack-dev-server 启动
            或者
            配置在package.json 例如:
            "scripts": {
            "start": "webpack-dev-server"
            }
            使用 npm start 或 yarn start 启动
         2. webpack-cli是4.* 版本 会和 webpack-dev-server 3.* 版本 不兼容
            启动 webpack-dev-server 会报错：Cannot find module 'webpack-cli/bin/config-yargs'
            可以换成启动 webpack serve 命令。
         3. 最终，我安装完毕后，通过`webpack serve` 成功启动。
         4. 至此，就可以使用 `localhost:8080` 加载页面了.

最终的文件构成：

```html
<!-- ///////////////////////// main.html //////////////////////// -->
<body></body>
<script src="./main.js"></script>
```

```js
///////////////////////// framework.js ////////////////////////
export function createElement(type, attributes, ...children){
    let element;
    if(typeof type === "string"){
        element = new ElementWrapper(type);
    } else {
        element = new type;
    }
    // in is key, of is value 
    for(let name in attributes) {
        element.setAttribute(name, attributes[name]);
    }
    for(let child of children) {
        if(typeof child === "string") {
            child = new TextWrapper(child);
        }
        element.appendChild(child);
    }
    return element;
}

export class Component {
    constructor(type){
        // this.root = this.render();
    }
    setAttribute(name, value){
        this.root.setAttribute(name, value);
    }
    appendChild(child){
        child.mountTo(this.root);
    }
    mountTo(parent) {
        parent.appendChild(this.root);
    }
}

class ElementWrapper extends Component {
    constructor(type){
        this.root = document.createElement(type);
    }
}

class TextWrapper extends Component {
    constructor(content){
        this.root = document.createTextNode(content);
    }
}



///////////////////////// main.js ////////////////////////
import {Component, createElement} from "./framework.js"

class Carousel extends Component {
    constructor(){
        super();
        this.attributes = Object.create(null);
    }
    setAttribute(name, value) {
        this.attributes[name] = value;
    }
    render(){
        // console.log(this.attributes.src);    //  打印一下，看看地址有没有被成功的传递进来
        this.root = document.createElement("div");
        for(let record of this.attributes.src) {
            let child = document.createElement("img");
            child.src = record;
            this.root.appendChild(child);
        }
        return this.root;
    }
    mountTo(parent){
        parent.appendChild(this.render());
    }
}

let d = [
"https://static001.geekbang.org/resource/image/bb/21/bb38fb7c1073eaee1755f81131f11d21.jpg",
"https://static001.geekbang.org/resource/image/1b/21/1b809d9a2bdf3ecc481322d7c9223c21.jpg",
"https://static001.geekbang.org/resource/image/b6/4f/b6d65b2f12646a9fd6b8cb2b020d754f.jpg",
"https://static001.geekbang.org/resource/image/73/e4/730ea9c393def7975deceb48b3eb6fe4.jpg",
];

// document.body.appendChild(a);
let a = <Carousel src={d}/>;
a.mountTo(document.body);
```

目前实现的功能：

- `<Carousel>`组件可以正确的被创建（div形式）；
- `<Carousel>`组件可以创建四个 img 子元素，用于插入四张照片；
- 四个 img 子元素，可以添加属性；
- 四个 img 子元素，添加的属性是 src，即：图片的地址。

总的来说，就是可以创建一个轮播组件，然后正确生成任意数量的 img 图片了。



## 2.2  轮播组件（2）

目前发现的问题： img 元素的特性，照片是一个鼠标可拖拽的，应当去掉这种效果。可以用 img 取消这个特性，或者直接用 div 包装，然后加入CSS属性：backgroundImage 更方便。

### tips:

- 轮播图的照片是每次只显示一张，很自然的想法就是，把照片的 CSS 都设置为： display:none。然后要显示哪一个，就把哪一个的 display 改变一下。这样会导致有一定的可能性出现两个图片同时显示的问题。（因为用户操作过快，导致js代码执行时出现顺序错误）。

  为了解决这个问题，不妨直接把 Carousel 组件的尺寸限定，而不是对子元素图片做修改。对Carousel 组件设置如下属性。其容器大小刚刚好就是一张图片的大小，然后超出的部分都做隐藏，这样绝对避免了有可能会出现同时显示两张图片的情况。

  ```css
  .carousel {
    overflow: hidden;
    width: 500px;
    height: 280px;
  }
  ```

- 如何让照片横行排放？ 用 正常流横排即可：
  - 照片元素：`display: inline-block`
  - 父容器：`white-space: norap` 不允许子元素换行。

- 给轮播组件添加时间控制：
  - 照片元素：`transition: ease 0.5s;` 添加一个缓动动画。
  - 在 render() 方法中，设置`setInterval()`，每隔一个固定周期，就调用回调函数。
    - 在`setInterval()` 中，每隔特定周期，就会令图片移动一次，达到轮播效果。
    - 如何让四张图片，在依次左移之后，可以恢复到第一张图片，重新开始循环。
      - 利用一个常用的技巧：如果想让一个数字 x 保持在 0 ～ (n-1) 之间循环，就用 n 对这个 x 取余即可：`x = x % n`。本例中，是 `current = current % children.length  `
  - 这时候发现，当最后一张切换到第一张的时候，有一个很难看的左滑过四张图片的动画，要解决这个问题：思考，想实现无限往同一个方向滑动，发现在滑动的时候，画面中最多只出现两张图片：当前图片，下一张图片。所以，只需要把这两张图片的位置确定好就可以了。
    - currentIndex --> curent
    - nextIndxt --> next
    - 如果当前图片位置是原点，那下一个图片的位置，是当前位置 + 100%，
      - 搞不懂就打开 Ai，自己画图看看。要严谨分析，就能分析清楚，难度不大。



要添加手势拖动效果，轮播不仅可以自动播放，也可以用鼠标拖动。接下来设计鼠标拖动。

- 设置鼠标监听，有三个事件：按下、拖动、松开（mousedown, mousemove, mouseup）。
  - 在设置的时候，利用 `console.log()`，随时观察事件是否触发，方便调整结构；
  - 正确的逻辑应该是：鼠标按下（mousedown触发）后，开始监听 mousemove 和 mouseup。当 mousedown事件结束，应该移除 mousemove 和 mouseup 事件。

```jsx
this.root.addEventListener("mousedown", event => {
  console.log("mousedown");

  let move = event => {
    console.log("mousemove");
  }
  let up = event => {
    console.log("mouseup");
    this.root.removeEventListener("mousemove", move);
    this.root.removeEventListener("mouseup", up);
  }

  this.root.addEventListener("mousemove", move); 
  this.root.addEventListener("mouseup", up); 
}); 
```



此时，遇到一个 bug，如果 mousedown事件触发，不松手，然后鼠标拖到图片区域之外，再松开鼠标。此时mouseup和mousemove应当被移除，但是没有被正确的移除。

- 原因：mouseup和mousemove的事件监听，不应该在 this.root 上，即不应该只在图片所在的这个容器上。应当在document上直接监听。

最终成品：

```jsx
this.root.addEventListener("mousedown", event => {
  console.log("mousedown");

  let move = event => {
    console.log("mousemove");
  }
  let up = event => {
    console.log("mouseup");
    document.removeEventListener("mousemove", move);
    document.removeEventListener("mouseup", up);
  }

  document.addEventListener("mousemove", move); 
  document.addEventListener("mouseup", up); 
}); 
```



## 2.3 轮播组件（3）

- 坐标的确定，用 clientX 和 clientY。浏览器中间可渲染区域的坐标。不会因为组件在网页中的位置改变，而影响坐标的变化，反正就是推荐用这个。

- 如果想让数字不出现负数，单纯的取余不行。
  - `pos = (pos + children.length) % children.length`
    - pos 的范围有可能在`[-1, 0, 1, 2, 3]`之间。为了让运算的结果， -1 转换为 3，-2 转换为 2。就先加一个周期长度 4（children.length），在正常的取余。

## 2.4 轮播组件（4）

分析问题的方法：

- `console.log()`打印变量。
- 用 Ai 画过程图。
- 断电监听变量。

### move 回调函数的逻辑：

```jsx
let move = event => {
  let x = event.clientX - startX;
  let current = position;

  for(let offset of [-1,0,1]) {
    let pos = current + offset;
    pos = (pos + children.length) % children.length;
    
    children[pos].style.transition = "none";
    children[pos].style.transform = `translate(${- pos * 500 + offset * 500 + x % 500}px)`;
  }
}
```

1. 先获取需要收集的参数：
   1. x 是鼠标滑过的相对位置
   2. current 是当前容器内的中心图片下标，取值：[0，1，2，3]，current 和 position 取值相同。
2. 然后分析轮播图的问题：当从静止的图片，向左 / 向右滑动的时候，最多只会展示中心图片（current）左边或右边的图片。最直接影响容器内展示的图片，就是三张图片。
   1. 定义这三张图片的位置：`offset = [-1, 0, 1]`。下标 0 就是轮播图容器内的中心图片。

![image-20201207103357128](source/image-20201207103357128.png)

2. 每当中心图片被滑动的瞬间，要改变左图 / 右图的位置。让 offset 控制的三张图片一起滑动。

3. 利用一个 let of 循环。找到 这三张图片，下标为 pos。

   - 因为offset = -1 的时候，指的是最后一张图片，也就是 current = 3。这里要把 -1 这个数值置换为 3 ，不希望出现负数。

     - 利用：`  pos = (pos + children.length) % children.length;` 。先加上一个周期（children.length 值为3），然后取余。就转换成了正书：
       - -2 转换为 2；-1 转换为3；0 转换为 0；1转换为1 ...

   - 把动画特效设置为 none，更改图片位置的时候，不能有缓动特效出现，影响图片移动速度。

   - 移动的距离，收到三个参数的影响：图片的 pos 位置、容器的 offset 位置、鼠标的移动 x 位置：

     - pos：pos 是图片的下标，事实上，pos的值和current、posotion都相等，代表了图片未移动之前的的实际下标。计算中，`- pos * 500` ，令图片移动到容器内框中。（比如第二张图片，pos = 1，移动 -500px，就把图片移动到了轮播图容器内了）。

       ![image-20201207104455293](source/image-20201207104455293.png)

     - offset：是图片相对容器的位置，计算中，先利用 pos 把图片移动到了容器中心内，然后利用 `+ offset * 500` 把图片根据 offset下标，相对位移到容器的左边 / 右边。

       ![/](source/image-20201207104514176.png)

     - x ：利用`x % 500`，对 x 取余。得到的结果就是鼠标当前的移动位置。如果不取余，x的移动位置包含了 n张图片 + 一张部分的图片。我们需要的是鼠标移动过程中，残存的部分图片的位置，所以要把整体图片的距离去掉，利用取余去掉。

       ![image-20201207104708805](source/image-20201207104708805.png)



### up 回调函数的逻辑：

```jsx
let up = event => {
  let x = event.clientX - startX;

  position = position - Math.round( x / 500);
  for(let offset of [0, - Math.sign(Math.round(x / 500) - x + 250 * Math.sign(x))]) {
    let pos = position + offset;
    pos = (pos + children.length) % children.length;
    if (offset === 0) {
      position = pos;
    }
    children[pos].style.transition = "";
    children[pos].style.transform = `translate(${- pos * 500 + offset * 500}px)`;
  }
  document.removeEventListener("mousemove", move);
  document.removeEventListener("mouseup", up);
}
```

up的执行，目的是让尚未完全拖动的图片，完成后面的动画：

![image-20201207150153005](source/image-20201207150153005.png)

这里会出现两个情况：

- 如果下一张图片的显示面积小于 1/2，则图片不切换到下一张，保持原位置（如上图）
- 如果大于1/2，则松开手后，图片自动切换到下一张。

Up函数没有看太明白... 

# 3 手势与动画

## 3.1 初步建立动画和时间线

16毫秒，是针对 60帧动画设置的时间长度。这是一个常识。

- ```jsx
  setInterval(() => {}, 16);
  // 每隔16毫秒反复调用箭头函数。
  // 有个弊端，16毫秒的调用不确保一定会执行。
  // 也有可能会出现事件挤压。总之是不稳定。
  ```

- ```jsx
  let tick = () => {
  		// some codes
      setTimeout(tick, 16);
  }
  // setTimeout 只执行一次，所以回调函数会命名一个函数。达到反复调用的目的。
  ```

- ```jsx
  let tick = () => {
    // some codes
    requestAnimationFrame(tick);
  }
  // 发出申请：当浏览器执行下一帧的时候，执行代码 tick。
  // 和浏览器的帧率相关，如果浏览器降帧时，动画也会降帧。
  // 现代浏览器常用 该方法。
  ```



### 一个完整的时间线结构：

```jsx
export class Timeline {
    // 初始化变量
    constructor(){ }
    // 启动
    start(){ }
    // 播放速率
    get rate(){ }
    set rate(){ }

    // 暂停 & 恢复
    pause(){ }
    resume(){ }
    
  	// 重启 初始化
    reset(){ }
}
```

​	

### 用 tick 表示时间线（tick -- '滴答'）

```jsx
////////// -animation.js- //////////
const TICK = Symbol("tick");
export class Timeline {
    constructor(){
        this[TICK] = () => {
            console.log("tick");
            requestAnimationFrame(this[TICK]);
        }
    }
    start(){
        this[TICK]();
    }
}


////////// -tick.js- //////////
import {Timeline} from './animation.js';
let tl = new TICK();
tl.start();
// 启动tl后，就可以看到在浏览器的console中，一直输出tick。实现了基本的tick逻辑。
```



### 实现思路：

```jsx
////////// -animation.js- //////////
export class Timeline {
    constructor(){
        // 动画队列。
        this[ANIMATIONS] = new Set();
    }

    start(){
        let startTime = Date.now();
        this[TICK] = () => {
            let t = Date.now() - startTime;
            for(let animation of this[ANIMATIONS]) {
                let t0 = t;
                if(animation.duration < t) {
                    this[ANIMATIONS].delete(animation);
                    t0 = animation.duration;
                }
                animation.receive(t0);
            }
            requestAnimationFrame(this[TICK]);
        }
        this[TICK]();
    }
      add(animation){
        this[ANIMATIONS].add(animation);
    }
}

export class Animation {
    // 参数：目标对象，属性值，初始值，末尾值，持续时间，差值函数（可选）。
    constructor(object, property, startValue, endValue, duration, timingFunction){
        this.object = object;
        this.property = property;
        this.startValue = startValue;
        this.endValue = endValue;
        this.duration = duration;
        this.timingFunction = timingFunction;
    }
    // time是 tick 时间，由timeLine构建的，表示该动画已经执行的时间
    // 动画已经执行的时间 + 尚未执行的时间 = 总时间 ===> time + 尚未执行的时间 == duration。
    receive(time){
        let range = this.endValue - this.startValue;
        // 均匀变化：（范围✖️虚拟时间）/ 持续时间
        this.object[this.property] = this.startValue + range * time / this.duration;
    }
}
```



- class Animation 是一个动画实例。这个实例通常会传入 5 + 1 个参数：
  - 实例属性：目标对象，属性值，初始值，末尾值，持续时间，差值函数（可选）。其中差值函数是可选的，它的作用就是对动画效果进行改变：缓动、快进快出等等。
  - 事实上，动画的目的就是，把目标对象的某个属性值 proterty，从 startValue 变成 endValue，中间执行的时间长度是 duration。
    - 比如：`new Animation(object, "a", 0, 100, 1000, null)`
    - 其含义是：对 object 对象执行一个动画：令他的 a 属性值，在 1000秒内，从0 变成 100。不使用差值函数，动画的效果是默认的“均匀变化”
  - receive() 函数：
    - 每个 tick 时序，都会执行 receive函数，这个时序的时间点就是参数 time。
    - range 是属性值要变化的范围；
    - 每隔时序对 object的这个属性值，按照算法，赋值一次。这里的算法没有用差值函数，而是均匀变化：`this.startValue + range * time / this.duration`

- class Timeline 构造了一个时间线，是一个节奏，相当于动画制作时候的时间轴。每一个 tick，都是一帧。所有动画都按照一帧一帧的执行。本质上讲，Timeline 就是把物理时间（毫秒）转换为了虚拟的帧动画。
  - constrcutor中，构造一个动画队列，所有要执行的动画，会通过 add(0 方法加入进去。
  - start() 启动时间轴
    - startTime：记录时间轴的初始时间；
    - 定义 TICK 函数，并且执行它；
      - `requestAnimationFrame(this[TICK])`： 会发出申请：当浏览器执行下一帧的时候，执行 TICK 函数。所以，会变成每隔一帧，就会执行一次 TICK函数，如此循环往复。
      - `t 变量`：该轮次 / 该帧的相对时间。代表了此时距离 start 启动，经过了多少时间。
      - `for循环`：每个 tick 时序，都会遍历所有队列中动画，依次执行一次这个动画的 `receive()`；
        - 当一这个动画的 animation.duration也就是持续时间，小于已经过的时间 t 时，表明动画应当执行完毕，此时执行两步：
          1. 把该动画移除动画队列中；
          2. 对 t0 赋值为动画的最大时间，也就是 animation.duration 持续时间。
          3. 定义 t0 的意义时：在通常时候，他都和 t 的值相同，都是表明已经经过的时间。只有当该动画要结束的时间点 —— 一旦出现 ` > animation.duration`，就表明该动画应当结束了。此时应当执行最后一次动画：`receive(animation.duration)`，而不能执行 `receive(t)`，因为此时的 t 值已经超出了动画执行的最大时间。t0变量，就是成为了确保动画永远不会超出执行的时间，最后在 if 为真的时候，把 animation.duration 赋值给 t0。

## 3.2 设计时间线的更新

其实如果分析懂了上面的代码，就会发现所有 在动画队列中的动画，只有duration代表动画的结束，没有变量代表动画的开始，所有动画在`start()`开始执行之前必须全部加载到队列中，然后 stat 后，全部同一时间启动。

- constructor中，添加一个参数 delay，代表该动画开始的时间。所谓“delay“，就是相对于 startTime，即start 起始时间而言的。本来所有动画都在 startTime开始执行，但如果需要推迟执行，就设置 delay。

```jsx
export class Timeline {
    constructor(){
        // 动画队列。
        this[ANIMATIONS] = new Set();
        this[START_TIME] = new Map();
    }

    start(){
        let startTime = Date.now();
        this[TICK] = () => {
            let now = Date.now();
            for(let animation of this[ANIMATIONS]) {
                let t;
                if(this[START_TIME].get(animation) < startTime ) 
                    t = now - startTime;
                else
                    t = now - this[START_TIME].get(animation);

                if(animation.duration < t) {
                    this[ANIMATIONS].delete(animation);
                    t = animation.duration;
                }
                animation.receive(t);
            }
            requestAnimationFrame(this[TICK]);
        }
        this[TICK]();
    }
      add(animation, startTime){
        if(arguments.length < 2){
            // 支持手动添加时间，如果不手动添加。赋默认值Date.now()。
            // 此处的startTime表示该动画的开始时间。
            startTime = Date.now();
        }
        this[ANIMATIONS].add(animation);
        this[START_TIME].set(animation, startTime);
    }
}
```

- constructor构造函数：添加了一个 Map数据结构，存放所有动画的添加时间：[animation, startTime]。

- `add 函数`：添加了一个 startTime 参数，这个参数代表该动画的添加时间，一旦动画被添加队列，就会在下一个 tick 中开始执行。同时，对 StartTime 设置了默认值：`Date.now()`

- start 函数：本质上没有改变，依然是每经过一帧，执行一次 TICK函数；

  - startTime 为初始时间轴

  - TICK函数，周期性执行：

    - now 变量：每一个 tick 的时间节点。表示当前时间。

    - for循环：在动画队列中，遍历所有动画。让每个 tick轮次，动画都能“动”一下（receive() 执行一次）

      - t 变量：确定每个动画的执行时间，可以看成是一个**进度条**：
        （t = valueStart 时，动画刚刚开始；t = valueEnd 时，动画刚刚结束）
        - 如果该动画的添加时间小于时间轴启动时间，表明动画是在 start() 还未开始就预先添加进来的，`t = now - startTime`。动画的开始时间，就是start的启动时间。动画的执行时间就是：当前时间 - start 启动时间。
  - 如果该动画的添加时间大于时间轴启动时间，表明动画是在 start() 启动之后，后添加进来的，`t = now +  this[START_TIME].get(animation)`。动画加入的时间在start启动时间之后，动画的执行时间就是：当前时间 - 动画加入的时间。
    

![image-20201207225440150](source/image-20201207225440150.png)
      
      - 执行 receive(t)，使动画产生效果。

## 3.3 给动画添加暂停和重启功能

给动画添加暂停和继续功能，为了看得更清楚，新建 animation.html 和 animation-demo.js 。

- 在 animation.html 中：
  - 创建了一个 div 用来展示动画。
  - 新建了两个按钮，一个控制暂停，一个控制重启。
- 在 animation-demo.js 中，对 div 新建了一个动画：
  - new Animation，该动画是： `transform: translateX(0px);`
    - 需要注意的是，这里的属性值，包含有一个 px 单位符号。所以对 Animation的 constructor 新增了一个变量 template。这个变量是一个匿名函数，保存了属性值的格式`v => translateX(${v}px)`。在使用时，只需要调用`template(value)`，即可赋属性值。

```jsx
////////// - animation.html - //////////
<body>
    <div id="el" style="width:100px; height:100px; background-color:lightblue;"></div>
    <button id="pause-btn">pause</button>
    <button id="resume-btn">resume</button>

    <script type="module" src="./animation-demo.js"></script>
</body>


////////// - animation-demo.js - //////////
import {Timeline, Animation} from './animation.js'

let tl = new Timeline();
tl.start();

// transform需要一个px作为属性的单位，用一个函数传入
tl.add(new Animation(document.querySelector("#el").style, "transform", 0, 500, 2000, 0, null, v => `translateX(${v}px)`));

document.querySelector("#pause-btn").addEventListener("click", ()=> tl.pause());
document.querySelector("#resume-btn").addEventListener("click", ()=> tl.resume());
```



然后，对 animation.js 做了修改，添加了 pause 和 resume 方法：

```jsx
const PAUSE_START = Symbol("pause-start")   // 暂停开始的时间
const PAUSE_TIME = Symbol("pause-time")     // 暂停结束的时间

start(){
  let startTime = Date.now();
  this[PAUSE_TIME] = 0;
  this[TICK] = () => {
    let now = Date.now();
    for(let animation of this[ANIMATIONS]) {
      let t;

      if(this[START_TIME].get(animation) < startTime ) 
        t = now - startTime - this[PAUSE_TIME];
      else
        t = now - this[START_TIME].get(animation) - this[PAUSE_TIME];
			// 对上面的两个 t 赋值，都剪掉 this[PAUSE_TIME] 偏移量。
      // 。。。。。 
}

pause(){
  this[PAUSE_START] = Date.now();
  cancelAnimationFrame(this[TICK_HANDLER]);
}

resume(){
  // 暂停了多久，暂停的总时间 = 当前时间 - 暂停的时间
  this[PAUSE_TIME] += Date.now() - this[PAUSE_START];
  this[TICK]();
}

add(animation, startTime){
    startTime = Date.now();
  }
  this[ANIMATIONS].add(animation);
  this[START_TIME].set(animation, startTime);
}
```

- `pause()` 新增了一个私有属性 PAUSE-START，记录按下暂停键的时间。
  - 按下暂停后，用 cancelAnimationFrame() 取消动画时间轴 timeline。
- `resume()` 新增一个私有属性 PAUSE_TIME，记录按下恢复按钮后，动画暂停了多久。也就是说，从按下暂停到再按下恢复，这中间经过的时间。
  - 为什么用 +=，因为这个 PAUSE_TIME，是一个偏移量。代表了经过暂停后，时间线应当往后推迟多久，或者说所有动画应当往后延迟 / 偏移了多久。
  - 重新启动 TICK 函数，令时间轴继续
- 在 start 中，
  - 先初始化 this[PAUSE_TIME] = 0; 此时尚未使用过暂停，偏移量为 0；
  - 然后在对 t 赋值的时候，需要减掉偏移量，所以，对所有 t 都剪掉 this[PAUSE_TIME]。



## 3.4 完善动画的其他功能

处理遗留问题：

Animation 的 delay、reset 和 timingFunction 参数对应的功能建立起来。



**delay**

- delay 就是动画加入动画队列后，不立刻开始执行，而是推迟一定的时间再去执行。很自然的，在 start 方法中，对所有的 t （进度条），剪掉一个 animation.delay 即可。
- 同时，需要注意的是，t 有可能存在被 animation.delay 减成负数的情况，这是因为该动画因为 delay 的存在，尚未达到开始执行的时间。这个时候因为尚未开始执行动画，不能进行 receive() 。添加一个判断，如果 t 大于 0 ，才执行 receive()。

![image-20201209091006995](source/image-20201209091006995.png)



**timingFunction**

timingFunction(v)，实质上就是输入一个0到1的时间，会对应输出一个0到1的进度。

cubic-bezier.com 可以查看各种缓动效果的函数曲线（x轴时间，y轴进度）

代码中，直接抄写了的浏览器中C++代码，改写成JS代码。然后，在 animation-demo.js 中，与 CSS 的缓动效果进行了对比。

- 不知道为什么，我的 ease 效果 和 CSS 中的不一样，找不到原因。时好时坏的样子。



**reset**

重置功能很简单，先执行 pause，令动画时间线停止；然后把所有记录全部清空：

```jsx
this.pause();
let startTime = Date.now();
this[PAUSE_TIME] = 0;
this[ANIMATIONS] = new Set();
this[START_TIME] = new Map();
this[PAUSE_START] = 0;
this[TICK_HANDLER] = null;
```



## 3.5 对时间线进行状态管理

添加一个 state 状态管理，更具有健壮性。

- constructor 中，对 state赋值为：Inited 初始化；
- start() 最开始进行判断，如果 state 状态不是 Inited，就不能启动，直接退出；
  - 如果 start() 启动，state赋值为：Started 已启动。

- pause、resume 情况类似：
- reset 直接重置：



**效果**：在程序运行的时候，反复的点 pause 和 resume 按钮，不会出现各种 bug 问题。保证了状态的一致。

```jsx
// constructor：
this.state = "Inited";  // 初始化。

// start：
if(this.state !== "Inited")
  return;
this.state = "Started";

// pause的开头
if(this.state !== "Started")
  return;
this.state = "Paused";

// resume的开头
if(this.state !== "Paused")
  return;
this.state = "Started";

// reset
this.pause();
this.state = "Inited";
```

# 4  手势与动画

## 4.1 手势的基本知识

### **gestrue**

### 单指手势的四种逻辑：点击、滑动、清扫、长按。

- 如果只是点击：start ----> tap
- 如果发生移动：
  - start ----> 移动10px ----> pan start ----> pan(move一次触发一次) ----> end ----> pan end (结束)
  - flick / swipe：如果在 pan(move) 过程中，速度特别快，就会判断为轻扫
- 按压：如果按下超过 0.5 秒，就会判定为 按压，出现 press start
  - 如果按下后，又移动了，则转换到正常的移动逻辑；
  - 如果按下后，没有移动而是松开了，则按压逻辑结束。

![image-20201209092711612](source/image-20201209092711612.png)



### touch 和 mouse

- 手势控制的常用四个事件：touchstart, touchmove, touchend, touchcancel
- 鼠标控制的常用三个事件：mousedown, mousemove, mouseup

- 手势控制的 touchstart 和鼠标控制的 mousedown 不同，touchstart 一定是针对某个物体触发，相应的添加 touchmove 事件，也是针对这个物体了。所以不需要像 mousedown 一样，需要把 mousemove 和 mouseup 放在 mousedown里面设置。
  - 为什么 mouse 系列设计的繁琐？因为鼠标一直会在页面中移动，而手指只可能在需要滑动的时候再会放在屏幕上，所以 touchstart、touchmove可以分开定义，他们一定是同一时间被触发的；而 mousemove 事件的监听的时机，需要 mousedown 事件被触发启动之后。
  - touchstart 支持多点触屏的监控，event 中存在多个触点。

### touchList 数组

```jsx
element.addEventListener("touchstart", event => {
    console.log("touchstart:");
    console.log(event.changedTouches);
});
element.addEventListener("touchmove", event => {
    console.log("touchmove:");
    console.log(event.changedTouches);
});
element.addEventListener("touchend", event => {
    console.log("touchend:");
    console.log(event.changedTouches);
});
```

可以看到，`event.changedTouches` 保存了所有触点信息，是一个TouchList数组，数组中每个成员是一个触点。

- identifier：是一个标识符，唯一标识了这个触点，也就是说，在 touchstart, touchmove, touchend 这三个事件监听中，特定的一个触点数值是相同的。
- clientX、clientY：表明了触点触发时的位置。

​	

![image-20201209152312476](source/image-20201209152312476.png)

### 遍历：触点信息

所以，利用 let of 就可以把所有触点分开，下图是尝试输出所有触点的位置信息：

```jsx
element.addEventListener("touchstart", event => {
    for(let touch of event.changedTouches) {
        console.log("start", touch.clientX, touch.clientY);
    }
});
element.addEventListener("touchmove", event => {
    for(let touch of event.changedTouches) {
        console.log("move", touch.clientX, touch.clientY);
    }
});
```

![image-20201209153215083](source/image-20201209153215083.png)

### touchcancel 事件

如果被系统打断（比如 `alert()` 弹窗）就会停止检测 触屏事件，然后不会触发touchend，而是触发cancel 事件，取消触屏事件监听：

```jsx
element.addEventListener("touchend", event => {
    for(let touch of event.changedTouches) {
        console.log("end", touch.clientX, touch.clientY);
    }
});
```

![image-20201209153823688](source/image-20201209153823688.png)

mouse不会出现被弹窗打断的问题，不会出现 “mousecancel” 的问题。



### touch 事件 和 mouse 事件的统一：

先把 mouse 和 touch事件监听的整体结构搭建好。然后，定义触点监听函数。

- mouse事件：
  - 需要注意整体结构，mousemove和mouseup需要在mousedown事件被触发后监听。还需要在该次mouseup的事件结束前，取消监听。
  - event 参数，就是触点信息。利用 start(event)等，就可以获取该事件触点的相关数据。
  - mouse事件中，mousemove 和 mouseup 的事件监听，要在 document 上。原因：用户在规定的监听容器内按下鼠标，有可能会拖拽鼠标到容器的范围外面，如果在 element 上监听 mousemove，就会导致鼠标一旦出了 element 范围，无法监听情况；在容器外面也无法监听 mouseup 。所以这两个 事件监听要在 document 上。而 mousedown 必须在 element 上。
- touch事件：
  - 整体结构分开监听即可，不需要有潜逃结构。
  - event 参数，是一个 touchList，需要迭代器遍历出每一个成员，每个成员是一个触点信息。利用 start(touch)等，可以获取该事件触点的相关信息。
- 触点逻辑：
  - 对每个事件触发是，触点的逻辑都写到这里，即可同时对鼠标和手指都监听到。

```jsx
// mouse事件
element.addEventListener("mousedown", event => {
    start(event);
    let mousemove = event => {
        move(event);
        };
    let mouseup = event => {
        end(event);
        document.removeEventListener("mousemove", mousemove);
        document.removeEventListener("mouseup", mouseup);
    };
    document.addEventListener("mousemove", mousemove);
    document.addEventListener("mouseup", mouseup);
});

// 触屏事件
element.addEventListener("touchstart", event => {
    for(let touch of event.changedTouches) {
        start(touch);
    }
});
element.addEventListener("touchmove", event => {
    for(let touch of event.changedTouches) {
        move(touch);
    }
});
element.addEventListener("touchend", event => {
    for(let touch of event.changedTouches) {
        end(touch);
    }
});
element.addEventListener("touchcancel", event => {
    for (const touch of event.changedTouches) {
        cancel(touch);
    }
});

// 触点逻辑：
let start = (point) => {
    console.log("start", point.clientX, point.clientY);
}
let move = (point) => {
    console.log("move", point.clientX, point.clientY);
}
let end = (point) => {
    console.log("end", point.clientX, point.clientY);
}
let cancel = (point) => {
    console.log("cancel", point.clientX, point.clientY);
}
```



可以看到，在鼠标按下 + 移动 + 松开，和手指按下+移动+松开，都得到了正确的监听。

<img src="source/image-20201209154913008.png" alt="image-20201209154913008" style="zoom:67%;" />



## 4.2 完善：手势的四种逻辑

#### 技巧：

- 先把所有定义的变量，放到全局作用域下（handler、startX、startY ...），方便先写整体逻辑。等所有逻辑定好后，再决定它们应该放到哪个作用域下更恰当。



#### 依次分析三个逻辑：

移动 pan

- 需要判断 isPan：是否按下后，移动超过10px。
- 移动的判断逻辑，在 move() 函数中；
- pan有两个状态：panStart 和 panEnd。



长按 press

- 需要判断 isPress：是否按下不移动，超过 0.5s。
  - 判断时间问题，主要定义一个 handler = setTimeout() ，设置 0.5s 后触发，如果被正确触发了，说明此时是一个 press 事件，如果没有触发这个 handler，说明此时不是 press，而是其他事件。任何一个其他事件被触发（pan、tap），在触发的时候，都会清楚这个函数，clearTimeout(handler)。
  - handler函数的内部，也要添加一个清除自身的代码 `handler = null;`。这样如果 handler 触发了，证明此时是一个 press 事件，不需要其他逻辑在执行 clearTimeout(handler) 去重复清除。所以让 handler = null。此时 setTimeout 失去了指向它的变量，不会被 clearTimeout(handler) 清空。

- 按下时间长度的判断逻辑，在 end() 函数中。
- press有两个状态：pressStart 和 pressEnd。 



单击 tap：

- 需要判断 isTap：是否按下不移动且没有超过0.5s，然后就松手了。

- 在end() 函数中，只要 isPan 和 isPress 都为 false，就可以确定此时的状态，应该是一个 tap。
- tap 只有一个状态：tap



默认：tap 状态是true，pan 和 press 状态是 false。此后，我们只需要去 pan 或 press 是否为 true。

- 如果为 true，则事件状态就不是 tap。而是 pan / press；
- 如果依然是 false，则此时一定进行到了 end() 函数，事件状态就是 tap。



`start():`

- startX：记录按下后的原始坐标。
- 把 isTap、isPan、isPress 初始化。
- 定义 handler 监控 0.5s 事件；
  - 一旦这个事件被触发，证明此时事件状态一定是 press：
    - 把 tap 和 pan 都置为 false；press 置为true；
    - 取消 handler 对该函数的指向，防止重复执行 clearTimeout。

`move():`

- 定义对 10px 移动的监控：
  - dx 和 dy 变量，实时记录位置 x 和 y 轴上的相对移动距离的量。
  - 判断：如果 dx 和 dy 的平方和大于 100，则证明移动已经超过了 10px，进入 pan状态。
    - 需要注意的是，此时移动依然会继续。但已经进入了 pan 状态，所以不需要再重复判断是否为 press。在 if 中，添加一个 对 isPress的判断解决这个问题。
    - 如果 if 为真，说明状态是 pan： tap 和 press 置为 false；pan 置为 true；
    - 同时，要清除对 0.5s的监控，避免 press 状态触发：clearTimeout()；



`end():`

- 对 tap、press、pan 分别判断是什么状态；
- 同时注意，tap如果为真，要消除 clearTimeout，避免进入 press 状态。



```jsx
let handler;
let startX, startY;
let isPan = false, isTap = true, isPress = false;

// 触点监听：
let start = (point) => {
    startX = point.clientX, startY = point.clientY;

    isTap = true;
    isPan = false;
    isPress = false;

    // 监控：0.5s事件
    handler = setTimeout(() => {
        isTap = false;
        isPan = false;
        isPress = true;
        handler = null;    // 如果执行了这里，表明 handler被执行，置为null，相当于自我删除。是为防止该setTimeout被多次clear。
        console.log("press");
    }, 500)
}

let move = (point) => {
    // 监控：移动10px
    let dx = point.clientX - startX, dy = point.clientY - startY;
    if (!isPan && dx ** 2 + dy ** 2 > 100) {
        isTap = false;
        isPan = true;
        isPress = false;
        console.log("panStart");
        clearTimeout(handler);
    }
    if(isPan) {
        console.log(dx,dy);
        console.log("pan");
    }
}

let end = (point) => {
    if(isTap) {
        console.log("tap");
        clearTimeout(handler);
    }
    if(isPan) {
        console.log("panEnd");
    }
    if(isPress) {
        console.log("pressend");
    }
}

let cancel = (point) => {
    clearTimeout(handler);
}
```



## 4.3 处理鼠标事件

可以发现，之前定义的 isPress、isTap、isPan，都不应该是全局变量：

- 对鼠标而言：鼠标事件要区分左键和右键；
- 对手势而言：手势事件要区分一共有几个触点；

解决方法：对 start move end 函数，额外传入一个 context 参数。context对象中保存着每个触点的信息。这样就避免了 start move end 函数直接从 外部的全局作用域中调用 isPress isTap 和 isPan 了。

```jsx
let start = (point, context) ...
let move = (point, context) ...
let end = (point, context) ...
let cancel = (point, context) ...
```

#### 触控事件：

定义一个 全局变量 contexts，采用 Map 数据结构，用来存放每个触点的信息。每个成员代表一个触点（key：identifier，value：context）。

- touchstart：一但 touchstart 被触发，证明有触点接触屏幕，把所有触点挨个遍历，创建对应的 context 空对象、用 identifier 标识符 唯一区分这些触点。然后调用 start 函数，同时传入 context 参数。
- touchmove：依次遍历得出每个触点，根据触点的 idenfifier 利用 get 获取各自的 context 信息。然后调用 move 函数，传入 context 参数；
- touchend：依次遍历得出每个触点，根据触点的 idenfifier 利用 get 获取各自的 context 信息。然后调用 move 函数，传入 context 参数；
  - 调用 and() 结束后，要 delete 删除该触点。先调用  and 方法，后删除触点。
- Object.create(null)
  - 作为 k/v 属性，用该方法创建对象是常用做法。可以防止继承Object的很多无用原始属性。

```jsx
let contexts = new Map();
//触屏事件
element.addEventListener("touchstart", event => {
    for(let touch of event.changedTouches) {
        let context = Object.create(null);
        contexts.set(touch.identifier, context);
        start(touch, context);
    }
});
element.addEventListener("touchmove", event => {
    for(let touch of event.changedTouches) {
        let context = contexts.get(touch.identifier);
        move(touch, context);
    }
});
element.addEventListener("touchend", event => {
    for(let touch of event.changedTouches) {
        let context = contexts.get(touch.identifier);
        end(touch, context);
        contexts.delete(touch.identifier);
    }
});
element.addEventListener("touchcancel", event => {
    for (const touch of event.changedTouches) {
        cancel(touch, context);
    }
});
```



#### 鼠标事件：

1. 鼠标原本会支持五个键的输出，利用 event.button 可以得到一个区分按键的 number。
   - MouseEvent.button：表明当前事件是由鼠标的哪个按键触发的。
   - MouseEvent.button：只能在 down 和 up事件中，正确获取鼠标按下对应的值。
   - MouseEvent.buttons：可以在任何鼠标事件中，获取鼠标的按键情况。

```jsx
element.addEventListener("mousedown", event => {
  	console.log(event.button);
});

0		// 左键
1		// 中键
2		// 右键
3		// 后退 侧键
4		// 前进 侧键
```

2. 在鼠标的 move 阶段，无法用 event.button 判断，采用 MouseEvent.buttons 来判断当前是哪个按键在按下 且正在移动。
   - 返回值：利用掩码来表示不同的按键情况，如果同时按下多个键，则结果相加。
     - `0 ` : 没有按键
     - `1 ` : 左键
     - `2 ` : 右键
     - `4 ` : 中键
     - `8 ` : 后退 侧键
     - `16` : 前进 侧键



Winter的解决方案：利用位移运算。

- 与 触控事件相同，利用 Map 结构的 contexts 存放数值。为了与触控事件的 key 相互区分，添加了"Mouse"作为开头。

- 在mousedown 事件刚触发 event.button 保存为 key 的时候，就预先进行了位移运算`1 << event.button`。
  - event.button 为 0 时，左移 0 位，结果乘 1：0000 0001       ->   1 
  - event.button 为 1 时，左移 1 位，结果乘 2：0000 0010       ->   2
  - event.button 为 2 时，左移 2 位，结果乘 2^2：0000 0100   ->   4
  - event.button 为 3 时，左移 3 位，结果乘 2^3：0000 1000   ->   8
  - event.button 为 4 时，左移 4 位，结果乘 2^4：0001 0000   ->  16
  - 这样，保存数值的时候，结果就已经是 event.buttons 的形式了。

- 在 mousemove 事件中，

  - 对变量 button 执行 while循环：

    - 在循环前，先定义变量 button = 1；
    - 只要 button 的值小于 event.buttons 就一直循环；
      - 判断：按位与运算 `button & event.buttons` 掩码成立的时候，才执行 move 回调。
        - 按位与：按将两个数值的每一位对齐，对相同位置上的两个数执行AND操作。只有两个数值的对应位都是1时才返回1，任何一位是0，结果都是0。
        - 这里为什么可以用 & 判断：event.buttons 这里只考虑单机的情况，也就是说二进制码中，一定是只有一位是 1，其他位是 0。button 和 buttons 的二进制，都只含有所以，这个判断的结果就是，如果 button 和 event.buttons 完全相同，为true。
        - 提取变量 button 值所对应的 key，获得 context，调用 move() 函数。
    - 每次循环，都对 button 做左移运算，直到 button 大于 event.buttons 循环结束。

  - 这里有一个问题需要处理：

    - event.buttons 的中键、右键，对应的数是：4 (0000 0100)、2 (0000 00010)。

    - event.button 的中键、右键，对应的数是：1、2，刚好与buttons相反。

      - button 在经过上面的位移换算后，中键、右键对应的是：2 (0000 00010)、4 (0000 0100)。

      ```jsx
      // 在循环中，用三个if分支，交换右键和中键的2和4
      while(button <= event.buttons) {
        if(button & event.buttons) {
          let key;
          if (button === 2) 
            key = 4;
          else if (button === 4) 
            key = 2;
          else
            key = button;
          let context = contexts.get("mouse" + key);
          move(event, context);
        }
        button = button << 1;
      }
      ```

      

新的问题：

在同时按下鼠标两个按键的时候，会报出错误。因为所谓鼠标同时按下，其实也是分先后顺序的：一定是先按下某个按键，在这个键没有松开的时候，又按下了另一个按键。这时候，先后按下两个按键，会触发两次 mousedown 事件：由此导致会创建两组 mousemove 和 mouseup 事件监听。事件监听被重复创建了。

- move 事件监听只有一个，这是鼠标移动事件的特性。但是鼠标在按下且移动的时候，MouseEvent.buttons，会根据同时按下的按键次数，累加数值。比如按下左键和右键，MouseEvent.buttons 的值为 3 = 1 + 2；
- 但是，mouseup 的事件监听两个，这样会起冲突，只需要一个 mouseup 事件监听。

解决方案：

设置一个全局变量： `isListeningMouse`，全局监控是否已经开启了监听，默认为 false，没有添加 mousemove 和 mouseup 事件监听。

- 在mousedown 事件中，添加 mousemove 和 mouseup 之前，先进行判断。 
  - 只有  `isListeningMouse` 为 false时，才可以添加。防止鼠标多个按键按下后，重复添加 mousemove 和 mouseup 事件监听。
  - 添加 mousemove 和 mouse up 后，还要把  `isListeningMouse` 置为 true，表明已添加这两个事件监听。

- 在 mouseup 回调函数中，判断：如果 event.buttons 的值为 0 ，表明此时已经没有按键被按下，这时候才把 mousemove和 mouseup 事件移除，同时把 `isListeningMouse`置为 false。

```jsx
let isListeningMouse = false;

// mouse事件
element.addEventListener("mousedown", event => {
    let context = Object.create(null);
    contexts.set("mouse" + (1 << event.button), context);

    start(event, context);
    let mousemove = event => {
        let button = 1;

        while(button <= event.buttons) {
            if(button & event.buttons) {
                // order of buttons & button property is not same
                let key;
                if (button === 2) 
                    key = 4;
                else if (button === 4) 
                    key = 2;
                else
                    key = button;
                let context = contexts.get("mouse" + key);
                move(event, context);
            }
            button = button << 1;
        }
    };

    let mouseup = event => {
        let context = contexts.get("mouse" + (1 << event.button));
        end(event, context);
        contexts.delete("mouse" + (1 << event.button));

        if(event.buttons === 0) {
            document.removeEventListener("mousemove", mousemove);
            document.removeEventListener("mouseup", mouseup);
            isListeningMouse = false;
        }
    };

    if(!isListeningMouse) {
        document.addEventListener("mousemove", mousemove);
        document.addEventListener("mouseup", mouseup);
        isListeningMouse = true;
    }
});
```



最终：当鼠标左键，鼠标右键等，先后按下，同时拖动，最后先后松开。`console.log` 中可以看到这两个按键互不干扰，分别监听。



## 4.5 派发事件

在 DOM 中，事件的派发，使用 new Event。

- 定义一个 派发事件。
- 参数：type，properties
  - type：传递一个string，表明事件类型。
  - properties：一个 k/v 对象。保存了一些相关数据。
- 在函数中：
  - 根据 type 新建一个 event 对象。 
  - 然后，遍历 properties，把数据赋值到 event 中。
  - 最后，把该 event 对象，dispatch 到 DOM 中。 

```jsx
// 定义一个 dispatch 派发事件。
function dispatch(type, properties) {
    let event = new Event(type);
    for (let name in properties) {
        event[name] = properties[name];
    }
    element.dispatchEvent(event);
}
```

尝试在 tap（单击）中，添加一个 派发事件：

```jsx
////////- gesture.js -/////////

// end()回调函数
let end = (point, context) => {
    if(context.isTap) {
        dispatch("tap", {});
        clearTimeout(context.handler);
    }
}


////////- gesture.html -/////////
<script>
    document.documentElement.addEventListener("tap", ()=> {
        console.log("tap event trigger!");
    })
</script>
```

浏览器中的结果：

![image-20201210203653689](source/image-20201210203653689.png)



## 4.6 实现 flick 事件

flick 是快速扫动，需要判断移动速度，超过阈值后，即为 flick 事件。

**速度的判断：**

- 如果只取两个点进行速度判断，会出现较大误差。因为两点如果取值过远，在这两点之间，用户滑动屏幕的速度不可能是平均的，几个极端情况：

  - 有可能刚开始非常快，后面非常慢
  - 有可能刚开始非常慢，后面非常快
  - 有可能刚开始和快结束的时候非常快，中建非常慢 
  - ...

  浏览器需要极快的反应，如果是第三种情况，用户刚开始就非常快的滑动，但是没有被立刻判定为 flick 状态。影响响应速度（两点取值求出速度后才判定 flick）。

  同时，不同浏览器对两点之间速度的判断也会随着取值过长而误差变大。

所以，应该进行 n 个取点，最后分别计算平均速度，然后再进一步判断。

在 move() 回调函数中，处理速度的提取和判断。



**代码实现：**

在 start 中，先定义一个存放多个点的数组。数字中，每个成员是一个对象，保存一点的相关信息。

	- 每个点保存三个数据：时间、x轴坐标、y轴坐标。
	- 然后存入第一点。

```jsx
    // start() 中：
    context.points = [{
        t: Date.now(),
        x: point.clientX,
        y: point.clientY,
    }];
```

在 move 中：

- `push()`：每次调用 move，都是鼠标的位置发生了一次变化，此时就把这个点，push到数组中保存：
- `filter`：在存入新的点之前，先对 points 的点进行处理，只保存 0.5s 之内的点。确保对速度的判断，总是最新的 0.5s。

```jsx
		// move() 中：
    context.points = context.points.filter(point => Date.now() - point.t < 500);

    context.points.push({
       t: Date.now(),
       x: point.clientX,
       y: point.clientY,
    });
```



在 end 中，分为三个部分：对点进行 fliter 过滤、求出速度 v、判断 flick 状态。

- 第一部分；在进行速度的判断前，仍要进行一次 fliter 过滤，确保接下来进行判断的点，一定是 0.5s 之内的。
- 第二部分：
  - 定义 d, v 变量，表示距离和速度。
  - 有可能存在这样一个情况：用户在松开鼠标前，使鼠标静止不动，超过了 0.5s。由于静止不动不会触发 mousemove 事件，因此也就不会添加额外的点。但在松开鼠标，进入 end 回调函数时，经过最后一次的 fliter 筛选，会把超出 0.5s 的点全部删除，此时有可能 points 数组的内容被清空：
    - 对数组的长度进行判断，如果数组为空，则定义 v = 0。用户肯定在松开鼠标前静止了 0.5s 以上；
    - 如果数组中存在点，则进行 v 速度计算：
      - 求 d ：利用两点平方和，然后开根号；
      - 求 v ：利用距离 / 时间差。
- 第三部分：
  - 经过测试，速度大于 1.5 像素/毫秒的时候，会比较快，此时可以判定为 flick 时间。
  - 如果是 flick 时间，则 isFlick = true；否则为 false。

```jsx
    context.points = context.points.filter(point => Date.now() - point.t < 500);
    
    let d, v;
    if(!context.points.length) {
        v = 0;
    } else {
    d = Math.sqrt((point.clientX - context.points[0].x) ** 2 + 
        (point.clientY - context.points[0].y) ** 2);
    v = d / (Date.now() - context.points[0].t);
    }

    // 速度大于 1.5 px/ns 像素/毫秒
    if (v > 1.5) {
        console.log("flick");
        context.isFlick = true;
    } else {
        context.isFlick = false;
    }
    console.log(v);
```



- 为所有状态，都添加派发事件。每个触点的相关数据，都存放在 contexts / context 中。
- 最终的代码： 

////- gesture.js -////

```jsx
// 取HTML元素
let element = document.documentElement;

let isListeningMouse = false;

// mouse事件
element.addEventListener("mousedown", event => {
    
    let context = Object.create(null);
    contexts.set("mouse" + (1 << event.button), context);

    start(event, context);
    let mousemove = event => {
        let button = 1;

        while(button <= event.buttons) {
            if(button & event.buttons) {
                // order of buttons & button property is not same
                let key;
                if (button === 2) 
                    key = 4;
                else if (button === 4) 
                    key = 2;
                else
                    key = button;
                let context = contexts.get("mouse" + key);
                move(event, context);
            }
            button = button << 1;
        }
    };

    let mouseup = event => {
        let context = contexts.get("mouse" + (1 << event.button));
        end(event, context);
        contexts.delete("mouse" + (1 << event.button));

        if(event.buttons === 0) {
            document.removeEventListener("mousemove", mousemove);
            document.removeEventListener("mouseup", mouseup);
            isListeningMouse = false;
        }
    };

    if(!isListeningMouse) {
        document.addEventListener("mousemove", mousemove);
        document.addEventListener("mouseup", mouseup);
        isListeningMouse = true;
    }
});

let contexts = new Map();

//触屏事件
element.addEventListener("touchstart", event => {
    for(let touch of event.changedTouches) {
        let context = Object.create(null);
        contexts.set(touch.identifier, context);
        start(touch, context);
    }
});

element.addEventListener("touchmove", event => {
    for(let touch of event.changedTouches) {
        let context = contexts.get(touch.identifier);
        move(touch, context);
    }
});
element.addEventListener("touchend", event => {
    for(let touch of event.changedTouches) {
        let context = contexts.get(touch.identifier);
        end(touch, context);
        contexts.delete(touch.identifier);
    }
});
element.addEventListener("touchcancel", event => {
    for (const touch of event.changedTouches) {
        cancel(touch, context);
    }
});

// 触点监听：
let start = (point, context) => {
    // console.log("start", point.clientX, point.clientY);
    context.startX = point.clientX, context.startY = point.clientY;
    context.points = [{
        t: Date.now(),
        x: point.clientX,
        y: point.clientY,
    }];

    context.isTap = true;
    context.isPan = false;
    context.isPress = false;
    context.isFlick = false;

    // 监控：0.5s事件
    context.handler = setTimeout(() => {
        context.isTap = false;
        context.isPan = false;
        context.isPress = true;
        context.handler = null;    // 如果执行了这里，表明 handler被执行，置为null，相当于自我删除。是为防止该setTimeout被多次clear。
        console.log("press");
    }, 500)
}

let move = (point, context) => {
    // 监控：移动10px
    let dx = point.clientX - context.startX, dy = point.clientY - context.startY;
    
    if (!context.isPan && dx ** 2 + dy ** 2 > 100) {
        context.isTap = false;
        context.isPan = true;
        context.isPress = false;
        console.log("panStart");
        clearTimeout(context.handler);
    }
    if(context.isPan) {
        // console.log(dx,dy);
        // console.log("pan");
    }

    context.points = context.points.filter(point => Date.now() - point.t < 500);
    context.points.push({
        t: Date.now(),
        x: point.clientX,
        y: point.clientY,
    });
    // console.log("move", point.clientX, point.clientY);
}

let end = (point, context) => {
    if(context.isTap) {
        // console.log("tap");
        dispatch("tap", {});
        clearTimeout(context.handler);
    }
    if(context.isPan) {
        // console.log("panend");
        dispatch("pan",{
            clientX: point.clientX,
            clientY: point.clientY,
        });
    }
    if(context.isPress) {
        // console.log("pressend");
        dispatch("press",{
            clientX: point.clientX,
            clientY: point.clientY,
        });
    }
    
    context.points = context.points.filter(point => Date.now() - point.t < 500);
    let d, v;
    if(!context.points.length) {
        v = 0;
    } else {
        d = Math.sqrt((point.clientX - context.points[0].x) ** 2 + 
            (point.clientY - context.points[0].y) ** 2);
        v = d / (Date.now() - context.points[0].t);
    }

    if (v > 1.5) {
        // console.log("flick");
        context.isFlick = true;
        dispatch("flick",{
            clientX: point.clientX,
            clientY: point.clientY,
        });
    } else {
        context.isFlick = false;
    }

    // console.log(v);
    // console.log("end", point.clientX, point.clientY);
}

let cancel = (point, context) => {
    clearTimeout(context.handler);
    console.log("cancel", point.clientX, point.clientY);
}

function dispatch(type, properties) {
    let event = new Event(type);
    for (let name in properties) {
        event[name] = properties[name];
    }
    element.dispatchEvent(event);
}
```

gestrue.html

```jsx
<script src="./gesture.js"></script>
<body oncontextmenu="event.preventDefault()"></body>
<script>
    document.documentElement.addEventListener("tap", ()=> {
        console.log("tap event trigger!");
    });
    document.documentElement.addEventListener("pan", (event)=> {
        console.log("pan event trigger!", event.clientX, event.clientY);
    });
    document.documentElement.addEventListener("press", (event)=> {
        console.log("press event trigger!", event.clientX, event.clientY);
    });
    document.documentElement.addEventListener("flick", (event)=> {
        console.log("flick event trigger!", event.clientX, event.clientY);
    });
</script>
```



## 4.7 封装

对组件进行解耦，可以发现大致分为三个部分：监听 listen、识别 recognize、分发 dispatch

- 信息的流向： listen => recognize => dispatch

- `class Listener` ：监听事件：鼠标、手势的所有事件，然后通过 start()、move()、end() 的形式，分发给 recognize；
- recognize：调用 dispatch。

```jsx
// 预期的调用结构：
new Listener(element, new Recognizer(new Dispatcher(element)));
```



对整体结构做如下的调整：

**Listener：**

- 把所有事件监听相关的内容，全部放入 class Listener 中的 constructor() 中。这是因为，在new Listener 时，让要创建所有的事件监听函数，在constructor中的代码，会在 new 的时候直接执行。
  - constructor 需要传入两个参数：element，recognizer。
    - element：事件监听绑定的对象；
    - recognizer：识别传入事件的回调函数；
      - 回调函数处理事件监听获得的触点信息，根据相应算法，从点的信息识别出用户的行为（点击、双击、扫过、移动等等），所以，回调函数的名称是 recognizer。

**Recognizer：**

- 把所有回调函数（start、move、end、cancel）放入 class Recognizer 中，当作 Recognizer 的实例属性。 Recognizer 的实力对象，被当作参数传入 Listener 的实例对象中。 通过 recognizer.start() 即可调用 回调函数。
  - constructor() 中，传入一个参数：dispatch。同时，定义一个 this.dispatch 保存派发信息。

**Dispatcher：**解决 element 参数传入的问题。

方法：把 function dispatch 改造成 class Dispatcher，这样可以把 element 变成参数传递给 dispatcher，当作它的实例属性。

- 把 function dispatcher 改造成一个 class ，这样方便把 element 参数传递给 dispatch方法中。

  - 在 constructor 中，添加 element 实例属性；

  - 把 dispatch 变成一个实例方法；

  - 这样，gesture 的调用的方式就转变为：

    `new Listener(element, new Recognizer(new Dispatcher(element)));`

    - 在 class Recognizer 类中，所有 `this.dispatch` 都变成 `this.dispatcher.dispatch`。
    - 在 class Recognizer 类中，constructor() 中传入的方法 dispatch ，变成一个对象 dispatcher。
    - 在 class Recognizer 类中，所有调用 `dispatch()`，都修改成 `this.dispatcher.dispatch();`





完善派发信息：

- press：在 `context.handler = setTimeout`中，末尾添加 press 的dispatch，因为一旦执行了 handler，就一定是一次 press 状态。在这里添加最合适。press 不需要任何附加信息，直接传入一个空对象给 dispatch。
- pressend：也没有任何参数，在 end 中判断。
- tap：在 end 中，先对 tap 进行判断，这里添加。
- panStart & pan：在 move中，只有两个逻辑，一个是 pan 系列，一个是对 flick 计算的触点记录。
  - panStart：需要记录移动的起始点坐标、移动时的点坐标、移动的方向 boolean（false 水平、true 垂直）
  - pan：记录的点，同上。
- panEnd： 在 end 中，panEnd 的判断时机，应该在 flick 之后。因为如果进入了 flick 状态，就是最终状态，不会再进入 panEnd 状态。但是，在 pan 状态中，只要速度 1.5 就会进入 flick 状态。
- flick：在 end 中。参数和panStart相同，多了一个 velocity，速度信息。
- cancel：在 cancel 逻辑中插入即可，不需要额外信息。



最后，利用  function enableGesture 方便 gesture 的调用。

- 使用时直接调用 enableGesture(元素) 即可。

  ```jsx
  <script type="module">
      import {enableGesture} from "./gesture.js";
      enableGesture(document.documentElement);
      // add some addEventListener.....
  </script>
  ```

enableGesture 函数的定义：

```jsx
export function enableGesture(element) {
    new Listener(element, new Recognizer(new Dispatcher(element)));
}
```



#  Part 3

# 1. 手势动画的应用

## 1.1 把 gesture.js 引入到 jsx 中

- 复制 gesture.js 到 jsx 中；

- 在 carousel.js 中，做 import 引入；

  ```jsx
  import {Component} from "./framework.js"
  import {enableGesture} from "./gesture.js"
  import {Timeline, Animation} from "./animation.js"
  import {ease} from "./ease.js"
  ```

**添加 pan 状态：**

在 render() 中，先注释掉 鼠标拖动功能模块、自动轮播模块，专注与 gerture 引入；测试一下 pan 事件是否可以顺利在 root 上，也就是照片容器内触发。

```jsx
enableGesture(this.root);
let children = this.root.children;
// 测试
this.root.addEventListener("pan", event => {
    console.log(event.clientX);
});
```

通过测试，看到 pan 状态可以顺利触发，则把 鼠标拖动功能开始往里添加，鼠标点击图片，然后拖拽，即可拖拽图片。

- pan 逻辑，就是之前的 mousedown 事件。把 mousedown 事件中 event 的代码稍作修改，即可添加进来：

```jsx
this.root.addEventListener("pan", event => {
    let x = event.clientX - event.startX;
    let current = position - ((x - x % 500) / 500);
    for(let offset of [-1,0,1]) {
        let pos = current + offset;
        pos = (pos % children.length + children.length) % children.length;
        children[pos].style.transition = "none";
        children[pos].style.transform = `translate(${- pos * 500 + offset * 500 + x % 500}px)`;
    }
});
```

**添加 pan end 状态：**

pan end 状态，就是鼠标松开，与之前 mouseup 时间相同。在添加 mouseup 事件的代码给 pan end 中时，删除掉 removeEventListener 因为都是通过 状态判断的，已经不需要有添加事件和移除事件: 

```jsx
this.root.addEventListener("panEnd", event => {
    let x = event.clientX - event.startX;
    position = position - Math.round(x / 500);
    for (let offset of [0, -Math.sign(Math.round(x / 500) - x + 250 * Math.sign(x))]) {
        let pos = position + offset;
        pos = (pos + children.length) % children.length;
        if (offset === 0) {
            position = pos;
        }
        children[pos].style.transition = "";
        children[pos].style.transform = `translate(${- pos * 500 + offset * 500}px)`;
    }
});
```

**添加时间线 timeline 和  自动播放**

由于之前的 ease 动画是通过 CSS 操作的, 不能随时停止动画的执行. 现在进行修改, 通过添加时间线, 利用 ease.js 中的动画来达到相同的动画效果. 

- 在最开头, 就创建一个时间线, 同时启动它 :

```jsx
enableGesture(this.root);
let timeline = new Timeline;
timeline.start();
```

- 为 current 和 next 添加动画事件:

```jsx
timeline.add(new Animation(current.style, "transform", 
      - position * 500, - 500 - position * 500, 
      500, 0, ease, v => `translateX(${v}px)`
));
timeline.add(new Animation(next.style, "transform", 
      500 - nextIndex * 500, - nextIndex * 500,
      500, 0, ease, v => `translateX(${v}px)`
));
```

此时, 图片自动轮播, 可以正常运作了.



## 1.2 将 自动轮播 和 用户行为 结合

当用户鼠标, 用户触屏影响到图片的时候, 自动轮播功能应该停止, 优先处理用户行为. 

暂停时间线的解决：

- 先在 gesture.js 中, 添加一个 "start" 的 dispatch. 用来表示, 用户一旦有触屏 / 点击的操作, 就启动 start 状态, 令自动轮播时间线暂停; 相应的, 后面也会添加一个 "end" 的 dispatch, 用来表示 用户的鼠标 / 手指离开屏幕后, 继续恢复 时间线中的自动轮播动画. 

  -  gestrue.js 中, 为 start() 函数 添加一个 start 状态.

  ```jsx
  this.dispatcher.dispatch("start", {
      clientX: point.clientX,
      clientY: point.clientY,
  });
  ```

  - carousel.js 中, 添加当鼠标按下时, 就启动的 start 事件监听函数, 图片自动播放就需要停止. 

  ```jsx
  this.root.addEventListener("start", event => {
      timeline.pause();
  })
  ```



时间线被暂停后，也要需要自动轮播动画 setInterval()。如果要取消 setInterval()，就不能是用箭头的回调函数，而是要对回调函数命名：

```jsx
// 在开始位置，定义变量 handler 用于保存 setInterval的回调函数
let handler = null;


// 重新定义 setInterval
let nextPicture = () => {
 	//  codes ....
}
handler = setInterval(nextPicture, 3000);


// 在 start 状态中，取消 setInterval
clearInterval(handler);
```



设置好 start 状态后, 图片可以在用户点击屏幕的时候, 会停止图的自动轮播. 但是此时会出现一个问题: 如果轮播在停止的时候, 是下图这样, 没有完全的, 切换为一张新的图片的时候, 因为没有正确记录此时图片的位置信息 (此时图片的位置不是 500 的整倍数, 而是在一个"过渡"的位置. )，所以图片就会出现瞬移的问题。

<img src="../../CSS/winterCSS/source/image-20201212181248534.png" alt="image-20201212181248534" style="zoom:50%;" />

动画挪动的额外距离，没有被计算进拖拽中。要把暂停时，当前图片的准确位置，传递给拖拽模块。

- 定义：
  - 变量 t ：自动轮播图片动画刚被添加的时间，也就是轮播动画开始执行的时间点；
  - 变量 ax：偏移量，由于动画自动轮播，该图片位移此时不满足 500 px 的整倍数，而额外移动的距离。
  - 变量 progress：（暂停动画时的时间 - 动话刚开始的时间） / 切换图片的时间 0.5s。得出的是此时该图的切换动画进度。
  - 则可以分析出： `ax = ease(progress) * 500 - 500;`
    - 函数 ease的参数，是一个代表进度的（0，1）之间的数字。上文提到过，（0，1）之间的数，作为时间进度传递给 ease 函数，然后经过处理，返回一个（0，1）之间的数，作为距离进度。0 代表动画尚未开始，对应位移距离就是0；1 代表动画刚好完成，对应位移应当是 1。
    - ease(progress) * 500 表明此时已经完成的动画位移量。因为图片已经移到下一帧，所以还要剪掉一个 500px。
- 在计算拖拽中，变量 x 也就是拖拽的偏移量时，额外减掉这个 ax。 
  - pan、panEnd 等等状态中。

最终，实现了在自动轮播过程中：

- 单机，使图的自动轮播暂停，可以正确拖动图片。

- 过程：网页加载，自动轮播开启（setInterval() + timeline 开启）==>
  -  鼠标按住图片，轮播停止
     - 进入 start 状态，暂停自动轮播（clearInterval() + 停止 timeline）
     - 进入 pan 状态，用户可以自由切换图片。



接下来需要解决 panEnd 的逻辑。令用户松开手后，图片在切换完毕后，继续开始轮播。

这个时候可以发现如果长按鼠标，会判定为 press 事件，此时 panEnd就不会触发。应该在 gesture 中，设计一个 end 状态，任何事件最终都会变成 end 状态。然后直接处理 end 状态的逻辑，即可把 pressEnd、panEnd、flick 状态一并处理了。

下列代码是处理 flick 状态 + end 状态的逻辑。 

```jsx
this.root.addEventListener("end", event => {
            
    timeline.reset();
    timeline.start();
    // 3秒钟后，重启自动播放
    handler = setInterval(nextPicture, 3000);

    if(event.isFlick) {
        if(event.velocity < 0) {
            direction = Math.ceil((x % 500) / 500);
        } else {
            direction = Math.floor((x % 500) / 500);
        }
    }

    let x = event.clientX - event.startX - ax;
    let current = position - ((x - x % 500) / 500);

    // [-1. 0. 1] 代表是哪个方向的图片
    let direction = Math.round((x % 500) / 500);

    for (let offset of [-1, 0, 1]) {
        let pos = current + offset;
        // 负数变正数
        pos = (pos % children.length + children.length) % children.length;

        children[pos].style.transition = "none";
        timeline.add(new Animation(children[pos].style, "transform", 
                                   - pos * 500 + offset * 500 + x % 500, 
                                   - pos * 500 + offset * 500 + direction * 500, 
                                   500, 0, ease, v => `translateX(${v}px)`));
    }

    position = position - ((x - x % 500) / 500) - direction;
    // 负数变正数
    position = (position % children.length + children.length) % children.length;
});
```



# 2. 为组件添加更多属性

通常情况下，要把所有局部变量，通常处理方式：

- 定义一个 Symbol 私有变量。代表“state”，用这个变量创建一个对象。然后，export 出去，把相关变量都绑定到这个对象中。

添加的组件1:

- triggerEvent，可以触发其他状态
  - onChange，可以检测到目前切换的图片是第几张；
  - onClick，可以点击图片，然后跳转到另一个网页。



实现 button 和 list，两种 children 的代表。

- Button.js
- List.js

























