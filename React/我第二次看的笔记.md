# 1 类式组件的结构：

1. 必须 **继承**。 `React.Component` ；
2. 必须有 **渲染方法**。 `render(){ return ...}`，在 render 中返回一个 HTML 结构。
3. 可以有 **自定义方法**，需要指出的是，自定义方法中的 this，没有指向当前实例对象。因为这个方法不是通过 `p1.callName()` 的方法调用的。也就是说调用者不是实例对象，而是 React 直接调用的。
   - 解决方案：`this.changeWeather = this.changeWeather.bind(this)`，使用 bind 函数，把这个 `changeWeather`  的 this 强制绑定到这个实例对象上。



### 一个类式组件的实例对象的结构：

![image-20211007144501255](%E6%88%91%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%9C%8B%E7%9A%84%E7%AC%94%E8%AE%B0/image-20211007144501255-16335891033111.png)

### `consructor` 

构造函数，仅用于以下两种情况：

1. 通过给 `this.state` 赋值对象来初始化内部 `state`。
2. 为事件处理函数绑定实例。 

- 所以，构造器可以直接省略：

1. 初始化 `state`，可以采用简写的形式，直接在类中定义属性 `state = {...}`
2. 事件处理函数，通过直接在类中定义一个属性，赋值箭头函数表达式：`changeWeather = () => {}`，既可以解决 this 问题，又省略了 constructor。

如果声明了构造器，但是忘记调用 `super(props)`，就会产生 bug，必须调用 `super()`，且传递 `props`。





### context







### props 

标签属性，组建实例的三大属性之一。用于传递标签属性。在 `constructor(props)`  中可以接受到 props，把 props 通过 `super(props)` 

- props 是 **只读** 的。

- 通常用字符串展开来传递属性，注意传递数字的时候，要用 `{}`；
- 可以对接收的数据类型进行限制。在类组件中，用静态对象 `static propTypes = {}`；在函数组件中，用属性 `Person.propTyps = {}`；
- 可以对接收的数据添加默认属性。在类组件中，用静态对象 `static defaultProps = {}`；在函数组件中，用属性 `Person.defaultProps = {}`；



### refs

标签名属性，组件实例的三大属性之一。组件内的标签，可以定义 ref 属性来标识自己。这相当于 HTML 中的 ID 属性。

refs 的最佳实践，官方最新版本的 createRef API。

refs 要尽量少使用，多使用事件机制。当发生事件的元素，就是要触发事件后进行操作的元素本身，就可以省略 ref，使用 `event.target.value`（课程P32，7:00，事件处理）



### state

状态，组件实例的三大属性之一。存储着组件的数据。

- 有两种写法：正常写和简写。
  - 简写不需要 `constructor` 和通过 `bind` 绑定解决自定义函数的 `this` 执行问题。
    - `constructor` 外部通过属性名定义的函数表达式，最后定义在了实例化对象上。所以，通过箭头函数去定义的 **函数表达式**，它的 `this` 就根据定义这个函数时的位置，指向了实例对象，这样就省略了 `bind` 去绑定 `this` 的指向。
- 修改 `this.state`，不能直接修改，通过 `this.setState()`  修改。



# 2 代码示例

## 2.1 State

头部文件：

```js
<div id="test1"></div>
<script type="text/javascript" src="../js/react.development.js"></script>
<script type="text/javascript" src="../js/react-dom.development.js"></script>
<script type="text/javascript" src="../js/babel.min.js"></script>
```

规范写法，繁琐：

```jsx
class Weather extends React.Component{
	constructor(props){
		console.log('constructor');
		super(props)
		//初始化状态
		this.state = {isHot:false,wind:'微风'}
		//解决changeWeather中this指向问题
		this.changeWeather = this.changeWeather.bind(this)
	}

	render(){
		//读取状态
		const {isHot,wind} = this.state
		return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
	}

	changeWeather(){
		//changeWeather放在原型对象上，供实例使用
		//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
		//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
		
		//获取原来的isHot值
		const {isHot} = this.state
		//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
		this.setState({isHot:!isHot})
	}
}

ReactDOM.render(<Weather/>,document.getElementById('test'))
```

### 1 最佳实践：

简写，解决 bind 和 constructor：

```jsx
class Weather extends React.Component{
    //初始化状态
    state = {isHot:false,wind:'微风'}

    render(){
        const {isHot,wind} = this.state
        return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
    }

	// 自定义方法————要用赋值语句的形式 + 箭头函数
    // changeWeather 放在实例对象上，而不在原型对象。这样通过箭头函数， this 就固定指向了实例对象。
    changeWeather = ()=>{
        const isHot = this.state.isHot
        this.setState({isHot:!isHot})
    }
}

ReactDOM.render(<Weather/>,document.getElementById('test'))
```



## 2.2 props

头部文件：

```jsx
<div id="test1"></div>
<script type="text/javascript" src="../js/react.development.js"></script>
<script type="text/javascript" src="../js/react-dom.development.js"></script>
<script type="text/javascript" src="../js/babel.min.js"></script>

// 如果需要对props进行限制和定义默认值，需要调用 prop-types库：
<script type="text/javascript" src="../js/prop-types.js"></script>
```

### 1 经典用法：

直接省略了 constructor 对 props 的传递。

```jsx
//创建组件
class Person extends React.Component{
    render(){
        // console.log(this);
        const {name,age,sex} = this.props
        return (
            <ul>
                <li>姓名：{name}</li>
                <li>性别：{sex}</li>
                <li>年龄：{age+1}</li>
            </ul>
        )
    }
}
//渲染组件到页面
ReactDOM.render(<Person name="jerry" age={19}  sex="男"/>,document.getElementById('test1'))

const p = {name:'老刘',age:18,sex:'女'}
// 通过扩展运算符，浅拷贝对象，达到传递值的目的，更简洁。
ReactDOM.render(<Person {...p}/>,document.getElementById('test3'))
// 传统方法，太繁琐。
// ReactDOM.render(<Person name={p.name} age={p.age} sex={p.sex}/>,document.getElementById('test3'))
```

### 2 对 props 进行限制：

在类中：

```jsx
class Person extends React.Component{
    render(){
        // console.log(this);
        const {name,age,sex} = this.props
        //props是只读的
        //this.props.name = 'jack' //此行代码会报错，因为props是只读的
        return (
            <ul>
                <li>姓名：{name}</li>
                <li>性别：{sex}</li>
                <li>年龄：{age+1}</li>
			</ul>
		)
	}
}
//对标签属性进行类型、必要性的限制
Person.propTypes = {
    name:PropTypes.string.isRequired, //限制name必传，且为字符串
    sex:PropTypes.string,//限制sex为字符串
    age:PropTypes.number,//限制age为数值
    speak:PropTypes.func,//限制speak为函数
}
//指定默认标签属性值
Person.defaultProps = {
    sex:'男',//sex默认值为男
    age:18 //age默认值为18
}
//渲染组件到页面
ReactDOM.render(<Person name={100} speak={speak}/>,document.getElementById('test1'))

function speak(){
    console.log('我说话了');
}
```

### 3 类组件的最佳实践：

在类中，经常采用以下方式简写：

```jsx
class Person extends React.Component{
	//对标签属性进行类型、必要性的限制
	static propTypes = {
		name:PropTypes.string.isRequired, //限制name必传，且为字符串
		sex:PropTypes.string,//限制sex为字符串
		age:PropTypes.number,//限制age为数值
	}

	//指定默认标签属性值
	static defaultProps = {
		sex:'男',//sex默认值为男
		age:18 //age默认值为18
	}
	
	render(){
        // props是只读的
		const {name,age,sex} = this.props
		//this.props.name = 'jack' //此行代码会报错，因为props是只读的
		return (
			<ul>
				<li>姓名：{name}</li>
				<li>性别：{sex}</li>
				<li>年龄：{age+1}</li>
			</ul>
		)
	}
}

ReactDOM.render(<Person name="jerry"/>,document.getElementById('test1'))
```

### 4 函数组件的最佳实践：

在函数组件中，使用 props：

```jsx
function Person (props){
	const {name,age,sex} = props
	return (
			<ul>
				<li>姓名：{name}</li>
				<li>性别：{sex}</li>
				<li>年龄：{age}</li>
			</ul>
		)
}
Person.propTypes = {
	name:PropTypes.string.isRequired, //限制name必传，且为字符串
	sex:PropTypes.string,//限制sex为字符串
	age:PropTypes.number,//限制age为数值
}

//指定默认标签属性值
Person.defaultProps = {
	sex:'男',//sex默认值为男
	age:18 //age默认值为18
}

ReactDOM.render(<Person name="jerry"/>,document.getElementById('test1'))
```



## 2.3 refs

### 1 过时方式：字符串形式

已 **不推荐使用** ：

```jsx
class Demo extends React.Component{
	//展示左侧输入框的数据
	showData = ()=>{
		const {input1} = this.refs
		alert(input1.value)
	}
	//展示右侧输入框的数据
	showData2 = ()=>{
		const {input2} = this.refs
		alert(input2.value)
	}
	render(){
		return(
			<div>
				<input ref="input1" type="text" placeholder="点击按钮提示数据"/>&nbsp;
				<button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
				<input ref="input2" onBlur={this.showData2} type="text" placeholder="失去焦点提示数据"/>
			</div>
		)
	}
}
ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
```

### 2 回调函数形式

在页面的 state 状态更新时，会调用两次 refs 的回调函数：

1. 第一次会把传递的参数置为 null，达到清空状态更新前的旧 refs 信息；
2. 第二次会正确的传递节点信息。

如果把回调函数放在 class 内部，而不是采用内联的形式，可以避免两次调用的问题，但事实上两次调用问题不大。

```jsx
class Demo extends React.Component{
	//展示左侧输入框的数据
	showData = ()=>{
		const {input1} = this
		alert(input1.value)
	}
	//展示右侧输入框的数据
	showData2 = ()=>{
		const {input2} = this
		alert(input2.value)
	}
	render(){
		return(
			<div>
				//ref 回调函数的参数，就是当前标签节点(input)对象。
				//所以，this.input1 = c 的意思是:
				//把指向自身节点对象的指针，放在了实例节点本身的input1属性上。
				<input ref={c => this.input1 = c } type="text" placeholder="点击按钮提示数据"/>&nbsp;
				<button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
				<input onBlur={this.showData2} ref={c => this.input2 = c } type="text" placeholder="失去焦点提示数据"/>&nbsp;
			</div>
		)
	}
}

ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
```

### 3 最佳实践：createRef 形式

```jsx
class Demo extends React.Component{
/* 
 React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,
 该容器是“专人专用”的，也就是一个节点，就创建一个对应的createRef对象。
*/
	myRef = React.createRef()
	myRef2 = React.createRef()
	//展示左侧输入框的数据
	showData = ()=>{
		alert(this.myRef.current.value);
	}
	//展示右侧输入框的数据
	showData2 = ()=>{
		alert(this.myRef2.current.value);
	}
	render(){
		return(
    <div>
        <input ref={this.myRef} type="text" placeholder="点击按钮提示数据"/>&nbsp;
        <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
        <input onBlur={this.showData2} ref={this.myRef2} type="text" placeholder="失去焦点提示数据"/>&nbsp;
    </div>
		)
	}
}
//渲染组件到页面
ReactDOM.render(<Demo a="1" b="2"/>,document.getElementById('test'))
```



# 3 事件机制

react 中的事件机制是采用委托形式。事件被触发后，会通过冒泡，在最外层的 div 中触发。



## 3.1 非受控组件

在表单中，所有输入类的 DOM，“现用现取”，就是受控组件。也就是说在获取到用户输入的内容后，直接取出来使用，而不是进行传递（不会进行表单提交的跳转，不会跳转网页）。

```jsx
class Login extends React.Component{
	handleSubmit = (event)=>{
		event.preventDefault() //阻止表单提交
		const {username,password} = this
       	// 阻止提交，然后现取现用，采用 ajax 提交。
		alert(`你输入的用户名是：${username.value},你输入的密码是：${password.value}`)
	}
	render(){
		return(
<form onSubmit={this.handleSubmit}>
	用户名：<input ref={c => this.username = c} type="text" name="username"/>
	密码：<input ref={c => this.password = c} type="password" name="password"/>
	<button>登录</button>
</form>
		)
	}
}
//渲染组件
ReactDOM.render(<Login/>,document.getElementById('test'))
```



## 3.2 受控组件

受控组件就是随着用户的输入，把输入的内容全部放入 state 状态中，这就是 “双向数据绑定”。

受控组件没有使用 ref，同时可以随时在 state 获取和使用用户输入的内容。



```jsx
class Login extends React.Component{
	//初始化状态
	state = {
		username:'', //用户名
		password:'' //密码
	}

	//保存用户名到状态中
	saveUsername = (event)=>{
		this.setState({username:event.target.value})
	}

	//保存密码到状态中
	savePassword = (event)=>{
		this.setState({password:event.target.value})
	}

	//表单提交的回调
	handleSubmit = (event)=>{
		event.preventDefault() //阻止表单提交
		const {username,password} = this.state
		alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
	}

	render(){
		return(
<form onSubmit={this.handleSubmit}>
	用户名：<input onChange={this.saveUsername} type="text" name="username"/>
	密码：<input onChange={this.savePassword} type="password" name="password"/>
	<button>登录</button>
</form>不     
		)
	}
}
//渲染组件
ReactDOM.render(<Login/>,document.getElementById('test'))
```



## 3.3 高阶函数 和 柯里化

### 1 高阶函数：

解决在事件回调函数中，不能传递参数的问题。因为回调函数应该是一个函数地址，而不是一个函数的调用，所以一定是 `func`，而不是 `func()`。

高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。

1. 若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。
2. 若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。

常见的高阶函数有：`Promise`、`setTimeout`、`arr.map()` 等等

一个需要高阶函数应用的场景就是：为了提高效率，想让多个节点的事件触发都调用同一个回调函数。为了让回调函数区分究竟是哪一个节点触发的回调，此时需要在节点绑定回调函数的时候，传递一个识别自身的参数，这时就需要高阶函数出马了：

```jsx
//创建组件
class Login extends React.Component{
    //初始化状态
    state = {
        username:'', //用户名
        password:'' //密码
    }

//保存表单数据到状态中。
//调用该函数，返回真正的回调函数。形成了一个闭包，保存了传递过来的 'username'或'password'参数，用来识别究竟是谁调用的回调函数。
saveFormData = (dataType)=>{
    return (event)=>{
        this.setState({[dataType]:event.target.value})
    }
}

//表单提交的回调
handleSubmit = (event)=>{
    event.preventDefault() //阻止表单提交
    const {username,password} = this.state
    alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
}
render(){
    return(
<form onSubmit={this.handleSubmit}>
	用户名：<input onChange={this.saveFormData('username')} type="text" name="username"/>
	密码：<input onChange={this.saveFormData('password')} type="password" name="password"/>
	<button>登录</button>
</form>
    )
}
}
//渲染组件
ReactDOM.render(<Login/>,document.getElementById('test'))
```



### 2 函数的柯里化

通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 

```js
function sum(a){
    return(b)=>{
        return (c)=>{
            return a+b+c
        }
    }
}
```

上文中，处理回调函数的方法也是一种柯里化：

在收到参数后，通过函数的层层嵌套，在最后 `return` 的时候统一处理。

```js
saveFormData = (dataType)=>{
    return (event)=>{
        this.setState({[dataType]:event.target.value})
    }
}
```



如果不使用柯里化：

```jsx
class Login extends React.Component{
    //初始化状态
    state = {
        username:'', //用户名
        password:'' //密码
    }

//保存表单数据到状态中
saveFormData = (dataType,event)=>{
    this.setState({[dataType]:event.target.value})
}

//表单提交的回调
handleSubmit = (event)=>{
    event.preventDefault() //阻止表单提交
    const {username,password} = this.state
    alert(`你输入的用户名是：${username},你输入的密码是：${password}`)
}
	render(){
 	   return(
<form onSubmit={this.handleSubmit}>
    用户名：<input onChange={event => this.saveFormData('username',event) } type="text" name="username"/>
    密码：<input onChange={event => this.saveFormData('password',event) } type="password" name="password"/>
    <button>登录</button>
</form>
 	   )
	}
}
//渲染组件
ReactDOM.render(<Login/>,document.getElementById('test'))
```



# 4 生命周期

































