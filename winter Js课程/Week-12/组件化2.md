# Port 3

# 1. 手势动画的应用

## 1.1 把 gesture.js 引入到 jsx 中

- 复制 gesture.js 到 jsx 中；

- 在 carousel.js 中，做 import 引入；

  ```jsx
  import {Component} from "./framework.js"
  import {enableGesture} from "./gesture.js"
  import {Timeline, Animation} from "./animation.js"
  import {ease} from "./ease.js"
  ```

**添加 pan 状态：**

在 render() 中，先注释掉 鼠标拖动功能模块、自动轮播模块，专注与 gerture 引入；测试一下 pan 事件是否可以顺利在 root 上，也就是照片容器内触发。

```jsx
enableGesture(this.root);
let children = this.root.children;
// 测试
this.root.addEventListener("pan", event => {
    console.log(event.clientX);
});
```

通过测试，看到 pan 状态可以顺利触发，则把 鼠标拖动功能开始往里添加，鼠标点击图片，然后拖拽，即可拖拽图片。

- pan 逻辑，就是之前的 mousedown 事件。把 mousedown 事件中 event 的代码稍作修改，即可添加进来：

```jsx
this.root.addEventListener("pan", event => {
    let x = event.clientX - event.startX;
    let current = position - ((x - x % 500) / 500);
    for(let offset of [-1,0,1]) {
        let pos = current + offset;
        pos = (pos % children.length + children.length) % children.length;
        children[pos].style.transition = "none";
        children[pos].style.transform = `translate(${- pos * 500 + offset * 500 + x % 500}px)`;
    }
});
```

**添加 pan end 状态：**

pan end 状态，就是鼠标松开，与之前 mouseup 时间相同。在添加 mouseup 事件的代码给 pan end 中时，删除掉 removeEventListener 因为都是通过 状态判断的，已经不需要有添加事件和移除事件: 

```jsx
this.root.addEventListener("panEnd", event => {
    let x = event.clientX - event.startX;
    position = position - Math.round(x / 500);
    for (let offset of [0, -Math.sign(Math.round(x / 500) - x + 250 * Math.sign(x))]) {
        let pos = position + offset;
        pos = (pos + children.length) % children.length;
        if (offset === 0) {
            position = pos;
        }
        children[pos].style.transition = "";
        children[pos].style.transform = `translate(${- pos * 500 + offset * 500}px)`;
    }
});
```

**添加时间线 timeline 和  自动播放**

由于之前的 ease 动画是通过 CSS 操作的, 不能随时停止动画的执行. 现在进行修改, 通过添加时间线, 利用 ease.js 中的动画来达到相同的动画效果. 

- 在最开头, 就创建一个时间线, 同时启动它 :

```jsx
enableGesture(this.root);
let timeline = new Timeline;
timeline.start();
```

- 为 current 和 next 添加动画事件:

```jsx
timeline.add(new Animation(current.style, "transform", 
      - position * 500, - 500 - position * 500, 
      500, 0, ease, v => `translateX(${v}px)`
));
timeline.add(new Animation(next.style, "transform", 
      500 - nextIndex * 500, - nextIndex * 500,
      500, 0, ease, v => `translateX(${v}px)`
));
```

此时, 图片自动轮播, 可以正常运作了.



## 1.2 将 自动轮播 和 用户行为 结合

当用户鼠标, 用户触屏影响到图片的时候, 自动轮播功能应该停止, 优先处理用户行为. 

暂停时间线, 重启时间线, 解决这个问题 :  

- 先在 gesture.js 中, 添加一个 "start" 的 dispatch. 用来表示, 用户一旦有触屏 / 点击的操作, 就启动 start 状态, 令自动轮播时间线暂停; 相应的, 后面也会添加一个 "end" 的 dispatch, 用来表示 用户的鼠标 / 手指离开屏幕后, 继续恢复 时间线中的自动轮播动画. 

  -  gestrue.js 中, 为 start() 函数 添加一个 start 状态.

  ```jsx
  this.dispatcher.dispatch("start", {
      clientX: point.clientX,
      clientY: point.clientY,
  });
  ```

  - carousel.js 中, 添加当鼠标按下时, 就启动的 start 事件监听函数

  ```jsx
  this.root.addEventListener("start", event => {
      timeline.pause();
  })
  ```

  















