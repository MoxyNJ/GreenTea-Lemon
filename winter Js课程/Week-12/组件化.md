# 组件化

--------------

# 1 组件基础 ｜ 组件的基本知识

前端最热门的两个话题：

- 组件化：主要目标就是复用。
- 架构模式：MVC、MVVC。关心前端和数据逻辑层之间的交互规则。

组件既是对象，又是模块。组件是一个与UI强相关的概念。可以以树形结构来组合。

## 1.1 组件 & 对象

### 对象

对象的三大要素：

- Properties 属性
- Methods 方法
- Inherit 继承关系（Javascript在运行时，原型继承）

### 组件

- Properties 属性
- Methods 方法
- Inherit 继承关系
- Attribute 特性
- Config & State 配置（预传参数） & 状态（随着人的操作/方法的调用，会发生变化）
- Event 事件机制（组件往外传递东西）
- Lifecycle 生命周期
- Children 树形结构的必要性



![image-20201130211032351](source/image-20201130211032351.png)

结构：左边是用户、中间是组件（或者说开发组件的程序员）、右边是程序员（或者说使用组件的程序员）

- 用户操作组件，会影响组件的 State状态（界面操作、输入文本），相应的，Children也可能会收到影响。

- 程序员通过 Attribute 去更改组件的特征 / 特性。
  - attribute：是声明型语言，markup language。
  - Property：和对象的Property的概念一致。直接设置组件上的属性。
  - attribute 和 Property 有时候统一，有时候不一样，这要看设计者的思路。
  - Property 在 Js 中，有 Get 和 Set 两个方法获取属性值，这一点上和 Method 有重合的功能。所以，根据不一样的设计者思路，有可能 Method 和 Property 也会是一个统一的概念。
- Event 的箭头是反过来的。可以看到，是开发组件的程序员向使用组件的程序员传递信息。

## 1.2 Attribute & Property

**Attribute**，强调描述性。描述一个对象的具体细节。

**Property**，强调从属关系。描述一个对象的是某个对象的子对象 / 父对象，体现从属关系。



### 举例：

在HTML中，property 和 attribute 就是不相同的概念：

```jsx
<!-- attribute -->
<my-component attribute="v" />

myComponent.getAttribute("a");
myComponent.setAttribute("a", "value");

<!-- property -->
myComponent.a = "value";
```



### 举例1

早年 JavaScript 中，class 是关键字，不允许 class 做属性名。现在允许了，HTML为了规避这一问题，区分了 attribute 和 property，做了如下改动：

- attribute：class，HTML依然不支持 class，只支持 className。
- property：className

```html
<div class="cls1 cls2"></div>

<script>
var div = document.getElementsByTagName('div');

// console 键入：
// property方法获取
div[0].className    // "cls1 cls2"
div[0].class        // undefined。property的命名，不是class，而是className。

// attribute方法获取
div[0].getAttribute("class");  // "cls1 cls2"
div[0].getAttribute("className");  // null
</script>
```



### 举例2

有些时候，attribute 和 property 之间的类型也不同。

- Attribute是一个字符串
- Proporty是一个字符串语义化的一个对象。

比如 style 属性在HTML中，attribute style 是一个字符串。可以用 getAttribute 和 setAttribute 修改 属性值。但是，用 proporty style 是一个 K-V 结构的集合，用来修改属性值更方便。所以，用 proporty 更方便。

```html
<div class="cls1 cls2" style="color: blue"></div>

<script>
var div = document.getElementsByTagName('div');
// console 键入：
div[0].style   //  一个对象。CSSStyleDeclaration {...}
div[0].getAttribute("style")     // "color: blue"
</script>
```



### 举例3

href 属性，attribute 和 property 的意思差不多。但是 Proporty是一个经过 resolve 过的 url。而 attribute 就是代码中写啥是啥。虽然两者语义非常相似，但是还是有区别。

```html
<a href="//m.taobao.com"></div>
<script>
    var a = document.getElementsByTagName("a");
    a[0].href                   // "file://m.taobao.com/"，这个URL是resolve的结果
    a[0].getAttribute("href")   // "//m.taobao.com"，跟HTML代码中完全一致
</script>
```



### 举例4

input 属性，value 是值是不相同的：

- attribute：value 是一个默认值。不论是用户在页面中修改 input 内容，还是程序员用代码给 proporty 赋值，它的 attribute 都是不会变的。
- property：在网页显示上，会优先显示 property 的值。
- attribute 和 property 可以分别定义，分别获取。两者是不等效的。

```html
<input value="cute" />
<script>
    var input = document.getElementsByTagName("input")[0];

    input.value     //"cute"
		input.getAttribute("value")     //"cute"
		input.value = "hello"           // 此时，value属性已经设置，则attribute不变，property变化。
  																	// 网页显示，会显示 property的 hello。
		input.value         //"hello"。property的值已经改变
		input.getAttribute("value")     //"cute"。attribute的值没有改变。
  
  	input.setAttribute("value", "world")	// 如果修改了attribute值
		input.value					//"hello"					// property的值不会改变。网页依然显示 hello
		input.getAttribute("value")						//"world" attribute被修改了。
</script>
```



## 1.3 如何设计组件状态

#### 四个场景

- Markup set：用标签去设置，静态声明语言。
- JS set：用 JavaScript 代码去设置。
- JS Change：用 JavaScript 去改变。
- User Input Change：由用户去改变。

![image-20201201082158071](source/image-20201201082158071.png)

State：状态通常是由用户去改变的，组件的设计者不会把改变状态的功能，设计给程序员。

config：是一个一次性的结果。只有在组件构造的时候会触发。是不可更改的。通常会把 config 留给全局。



## 1.4 Lifecycle

生命周期：created + destroyed

![image-20201201083104433](source/image-20201201083104433.png)

1. mount：组件挂到屏幕上。一个组件，在创造后，会被屏幕显示出来。即放到了 DOM 树上。
   - umount：组件从屏幕上卸下。
   - mount 和 unmount 有时会反复发生，一个循环。
2. JS change / set：组件的使用者（程序员）
3. User Input：终端用户
   - 程序员或终端用户在点击/修改组件时，触发组件更新。进入一个循环。



## 1.5 Children

Content 型 & Template 型

- Content型：有几个 Children，最终就能显示几个 Children
- Template型：Children充当了一个模板的作用。

例如，设计一个 list，Template型 Children 构造了一个 list 的结构。但是，这个 list 在真实的使用时，Children 的具体数目是不确定的。在 list 使用时，会传入一个 data，根据数据项的个数，构造相应长度的 list。如果接受了一个100项的数据，就会有100个实际的 Children，模板会复制 100份。 

```html
<!-- Template型 -->
<my-button><img src="{{icon}}"/>{{title}}</my-button>

<my-list>
	<li><img src="{{icon}}"/>{{title}}</li>
</my-list>
```



# 2 为组件添加JSX语法 ｜ 组件的基本知识

1. 在终端中：

   1. `mkdir jsx` 创建文件夹
   2. `cd jsx`
   3. `npm init` 然后所有选项不去更改，npm就创建好了。
   4. `npm install -g webpack webpack-cli` 用npm 全局安装 webpack包
      1. `npm install -g npm` npm更新
   5. `npm install -save-dev webpack babel-loader`安装 babel-loader(安装到本地目录中), babes plugin
      - 四个包的功能：
        - webpack：把一个普通的 JavaScript 文件，能够和不同 import 或 requre 一起打包。
        - babel：把一个新版本的Js编译成一个老版本的Js，可以让文件支持更多的老版本浏览器。

2. 打开 vs code：

   1. 在jsx文件夹中，创建 webpack.config.js。
      1. 设置好 entry，指向 main.js
   2. 创建 main.js。可以先定义一个简单的代码。
   3. 打开调试 ==> 创建 launch.json ==> 打开 终端 ==> 键入：webpack
   4. 可以看到，此时生成了 dist 文件夹 ==> 里面的 main.js 进过了加工。

3. 继续在 vs code中：

   1. 安装 babel，终端键入：`npm install --save-dev @babel/core @babel/preset-env`

   2. 在 webpack.config.js中，加入 module，引入 babel。
   3. 测试，终端键入：`webpack` 显示编译成功。
   4. 再看 dist/main.js中，可以看到之前到 for...of 语句，已经被编译为基本 for 循环，适配低版本的 JavaScript 代码了。  

4. 在 web pack.config.js中，添加 `mode:"development"`，开发者模式。

   1. 此时，再看 dist/main.js 中，可以看到代码不再压缩，可以直接调试生成的代码本身。

5. 在 main.js 中，常识输入一些 JSX代码，之后直接终端 `webpack`，发现会报错。这是因为没有引入 JSX。

   1. 终端键入：`npm install --save-dev @babel/plugin-transform-react-jsx`
   2. wabpack.config.js 中，配置上该包。
      1. 测试，终端：`webpack`。显示成功。JSX成功引入。
      2. 原先在 main.js 中测试的JSX代码：`let a = </div>`，在 dist/main.js 中，转义为`React.createElement(\"div\", null);`。















# 2 轮播组件化



# 3 手势与动画



# 4. 

























