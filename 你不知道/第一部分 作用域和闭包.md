# 1 作用域是什么

## 1.1 编译原理

提前编译：C语言是提前编译的，需要把原始文件.c 的文件编译为 .s .exe 等可以直接执行的格式，然后会执行。

### 编译流程

#### 编译类语言的编译流程（Java、C）：

- 分词 + 词法分析（Tokenizing/Lexing）
  - 划分词法单元（token）。把代码分解成一个个代码块，每个代码都是一个 token。
- 解析 + 语法分析（Parsing）
  - 转换抽象语法树（Abstract Syntax Tree，AST）。一个逐级嵌套的程序语法结构树。
- 代码生成（create）
  - 生成可执行的代码。

#### 解释型语言的编译流程（JavaScript、Python）：

不需要对代码进行提前编译，生成可执行文件，然后执行这个文件。而是把编译和执行压缩为一个流程，通常在执行代码前的微秒级内编译完毕。编译后立即执行。



可以这样理解：

编译型语言，没有引擎这个中枢控制，而是直接划分为两个阶段：编译、执行。

解释型语言，有一个总控制”引擎“。代码的执行被划分为：编译时、运行时，这两个阶段。在执行代码时前后进行。



## 1.2 Js的执行流程：

## 1.2.1 角色划分：

引擎：控制整个JavaScript 程序的编译、执行过程。神经中枢。

编译器：管理编译部分的工作。划分 token、转换 AST、生成可执行代码。

作用域：维护一系列查询。包括对所有已经声明的变量（标识符）的可访问权限。



以 `var a = 2;` 为例，全部流程由引擎控制：

1. 编译时，编译器完成以下操作：
   1. 划分词法单元（Token）。
   2. 解析为语法结构树（AST）。
   3. 代码生成，此处区别于编译型语言：
      1. 编译器向引擎询问：作用域中是否已经有一个相同的变量名称。
         1. 如果有，则编译器忽略该声明，只执行编译工作（编译赋值操作）；
         2. 如果没有，则编译器会通过引擎，通知作用域在当前作用域下，进行一个变量声明，然后执行编译工作（赋值操作）；
         3. 引擎在收到编译器的问询后，会对作用域进行问询，然后编译器和作用域之间反馈结果。
      2. 编译器生成运行时所执行的代码，是一个赋值操作。
2. 运行时，引擎完成以下操作：
   1. 引擎运行到此处代码，会询问作用域，当前作用域集合是否存在该变量（a）。
      1. 如果有，则引擎会使用这个变量，完成后面的操作；
      2. 如果没有，则引擎会询问上级作用域，是否存在这个变量，以此类推；
      3. 最终如果依然没有找到，则抛出异常

#### 简短的总结：

- 编译时：编译器会让作用域在当前作用域中，声明一个变量。
- 运行时：引擎会查询作用域，是否存在该变量。



## 1.2.2 编译器的查找方式

### 1 查找方式分类：

**LHS 左引用（左侧查找）**

变量出现在赋值操作的左侧（`a = 3`）。赋值操作的目标（LHS）

目的是把右侧的值，赋值给这个变量。即改变这个变量的当前值。



**RHS 右引用（右侧查找）**

变量出现在赋值操作的右侧（`console.log(a)`）。赋值操作的源头（RHS）

目的是得到这个变量的值，取得他的源值，赋值给别人。而不是对这个值进行赋值操作，改变这个值。



### 2 LHS 和 RHS 的对比

#### 相同点：

存在作用域链、或称之为作用域嵌套：如果引擎在询问一个变量，没有在当前作用域中找到时，会向父级作用域查找，一层层向上查找知道找到结果，返回他；或没有找到，执行其他操作。



#### 不同点：

上文说到，在作用域链层层向上、从内而外、从下至上查找，没有找到最终的变量时，LHS和RHS有不同的应对策略：

- LHS：如果在顶层（全局作用域）中没有找到目标变量，则会自动在全局作用域中创建一个该变量，同时返回给引擎。
  - 严格模式下，和 RHS的应对策略相同。
- RHS：如果在顶层（全局作用域）中没有找到目标变量，就会报错：**ReferenceError 异常**。

补充：对若 RHS 成功找到并给引擎返回了该变量，在接下来对这个变量进行赋值操作时，发生了不合理操作（比如对一个普通变量进行函数调用），就会报错：**TypeError 异常**



### 3 遮蔽效应

类似函数的复用：作用域的查找会在找到第一个匹配的标识符时停止。这样多层嵌套的作用域中，可以覆盖同名定义的变量。

有一定的方法去访问被覆盖的变量：

- 全局变量会自动定义在全局对象中。可以直接通过全局对象访问它们。比如浏览器中的 window对象，定义在全局作用域中的变量，可以直接通过 window.xxx 来访问。



# 2 词法作用域

## 2.1 作用域的两种工作模型：

#### 动态作用域

动态作用域中，对作用域的定义发生在运行时。

动态作用域不关心函数和作用域是如何声明以及在何处声明的，只关心它们从**何处调用**。作用域链是基于调用栈的，而不是根据代码结构的作用域嵌套。JavaScript 中， 在 箭头函数中，this的使用类似这种模式。

#### 词法作用域

词法作用域中，对作用域的定义发生在编译时。
换句话说，每个变量都有一个对应它的词法作用域：无论函数在哪里被调用，无论如何调用，它的词法作用域都**只由函数被声明时所处的位置决定**。

- 词法作用域只查找一级标识符，如果存在这样一个代码：`func1.func2.func3.a` 。词法作用域查找只会在 func1标识符内查找，找到变量 a 后，返回给引擎。剩下的 func2 和 func3 的访问，就是归对象属性的访问规则负责了。

- 根据代码的层层结构，形成了作用域链。是计算机编程语言的普遍处理方式，JavaScript就是这种方式。



## 2.2 欺骗词法

## P17 待更新⌛️ 



# 3 函数作用域 & 块作用域

作用域如果按照使用范围来考虑，划分为两种作用域：函数作用域和块作用域。







#### 1. 函数作用域

#### 2. 块作用域

































#### 