## 正常流

### 1. 盒模型

#### 1.0 box-sizing

`box-sizing` 设置 `width` 宽度的作用范围；

- `content-box`：默认，`width` 就相当于 `content` 的宽度，其只作用于 `content` 区域。
- `border-box`：`width` 作用于 `content` + `padding` + `border` 三个区域。

默认情况下，盒子的总宽度 == `width` + `padding` + `border`

设置了 `border-box`,盒子的总宽度 ==  `width`

- `border-box` 盒子是 IE 的老标准。



#### 1.1 display 显示类型

设置元素的外部和内部显示类型。

- 外部显示类型：决定了该元素处在正常流中的表现：是块级元素，还是内联级元素。

- 内部显示类型：决定该元素的后代元素排版 / 布局方式：flow layout、grid、flex。

##### 可选的值（1+5+5+2）：

默认：

- `static`：默认正常流 flow layout。遵循 CSS 2 系列的排版规则，是一个 BFC / IFC。

外部显示类型为`block`：

- `block`
- `table`：外部显示为 `block`，内部显示为 `table`。
- `flex`：外部显示类型为 `block`，内部显示类型为 `flex`。
  - 该盒子的所有直接子元素都会成为 flex 元素，会根据弹性盒子（Flexbox）规则进行布局。
- `grid`：同上，内部会变成 grid 盒子。 

外部显示类型为 `inline`：

- `inline`、`inline-table`、`inline-flex`、`inline-grid`：与上文对应，外部显示为 `inline`。

- `inline-block`：外部显示类型为 `inline`，内部显示类型为 `block`，这个盒子能设置 `width` 了。

其他：

- `list-item`：元素创建为盒子后：一个主块盒 + 一个标记盒。
- `none`：该元素和后代都从 DOM 中删除。



##### `inline-block` 的特性：

内部显示类型为块级元素 block-level element，外部显示类型为行内级元素 inline-level element。

- 拥有部分 block 的性质：
  - width、height 有效，可以设置盒子内容 content 的大小；
  - padding、margin、border 会推开其他盒子。

- 拥有部分 inline 的性质：
  - 盒子不会主动换行，多个内联块盒子会并排排放，和正常流一样，只有达到边界才会 “被迫” 换行；

- 问题：
  - 如果设置了 width 内容宽度：则该盒子内的文本内容，会在盒内换行，不会横向溢出盒子。一但文本内容过多，就会纵向溢出盒子。
  - 如果没有设置 width 内容宽度：则该盒子的宽度，会随着文本内容的增多而撑开。但是如果盒子边界达到容器宽度，文本内容会在盒子中换行。
- 总结：` inline-block` 内联块盒，也就是说，是盒子之间内联关系的，内部块级的盒子。



#### 1.2 position 定位方式

通过 position 确定定位方式。参考包含块，通过 top, right, bottom, left 属性确定偏移量。

##### 可选的值（5）

- `static`：默认定位。元素按照正常流的方式排版， 盒偏移量（top, right, bottom, left 属性）无效。
- `relative`：相对定位。先按照 **正常流排版**，然后按照 原始位置为基、盒偏移量为距离进行定位。
- `absolute`：绝对定位。先 **脱离正常流**， 然后按照 包含块为基、盒偏移量为距离进行定位。
- `fixed`：固定定位。先 **脱离正常流**，然后按照 包含块（绝大多数情况下是 **视口**）为基、盒偏移量为距离进行定位。
- `sticky`：粘性定位（CSS3）。是 **相对定位** 和 **固定定位** 的混合。基于盒偏移量值进行偏移。
  - 元素在跨越特定阈值（盒偏移量）前为相对定位，之后为固定定位。



#### 1.3 float 与清除浮动

让元素 **脱离正常流**，沿其容器的左侧或右侧放置，容器内的其他 **文本** 和 **内联元素** 会添加 `margin` 后环绕它。

##### clear 清除浮动

**向下移动**：不允许被清除浮动的元素的左边/右边挨着浮动元素。让它移动到它左边/右边浮动元素的下面。

- 针对 float 元素：可以让该 float元素 **不是平移** 的方式排到其他浮动元素后，而是 **另起一行拍到第一个** 。
- 针对 非float 元素：可以让该元素的文本 / 内联元素，不是环绕 float 元素。而是将该元素的内容全部移到 float 元素的下方。同时会发生外边距折叠。


值：none、left、right、both



### 2. 格式化上下文

- Formatting context：格式化上下文
- Block formatting context：块级格式化上下文，简称 BFC。
- Inline formatting context：行内级格式化上下文，简称 IFC。

在一个BFC中，所有块级元素，会从包含块的内容块(content)顶部开始，在 **垂直方向** 依次排版。

**BFC 对 float / clear 的影响：**

- **浮动定位** 和 **清除浮动** 时只会应用于同一个 BFC 内的元素。
- **浮动** 不会影响其它 BFC 中元素的布局，而 **清除浮动** 只能清除同一 BFC 中在它 **前 / 后面的元素** 的浮动。
- 计算 BFC 的高度时，内部的浮动元素也要参与计算（解决 float 高度坍塌）。

**BFC 对 外边距折叠的影响：**

- 外边距折叠（Margin collapsing）只会发生在属于同一 BFC 中。
- 只要是在同一个 BFC 中，块元素不论父子结构，在纵向上都会折叠。**兄弟** 、**父子** 块级元素都会发生。

**注意：IFC、flex、grid 之间都不会发生 Margin Collapse。**因为边距折叠只会发生在一个 BFC 中，如果创建了新的BFC，就不会发生边距折叠。



#### 2.1 BFC 的生成条件 (5)：

- 该元素内部必须是一个 block-level element：因为内部显示类型只有是块级元素，才会生成块级格式化上下文 BFC。
- 该元素的内部可以放正常流：反情况理解，如果内部不能防止正常流（比如，块级的替换元素 img，内部不受 CSS 样式影响，flex 内部必须放置 flex-item 等），那该元素的内部就不会生成一个 BFC，而是会放置特定的内容物。

具体情况（5）：

- `<html>` 根元素。
- `float` 元素。
- `position` 脱离正常流元素。`fixed`、`absolute` 固定定位、绝对定位的元素。
- `display` 创建包含块元素：
  - 内联块和列表：`inline-block`、`list-item`
  - 表格相关：`table-cells`、`table-captions`、`table`、`inline-table`；
  - `flex` 和 `grid` 相关：fiex item、grid cell。

- `overflow` 非 visible 元素。overflow：hidden、scroll、auto。
  - `overflow` 属性是当内容移除元素边框时的处理方式。




### 3. 高度坍塌和清除浮动

高度坍塌：指父元素本来应该包括子元素的高度，但是实际上父元素比子元素的高度要小。

```html
<style>
  .container {
    background: rgb(253, 234, 234);
  }

  .box1 {
    float: left;
    width: 200px;
    height: 200px;
    background-color: rgb(0, 225, 255);
  }

  .box2 {
    width: 400px;
    height: 100px;
    background: rgb(160, 235, 74);
  }
</style>

<div class="container">
  <div class="box1"></div>
  <div class="box2"></div>
</div>
```

![image-20211123170444733](images/%E6%AD%A3%E5%B8%B8%E6%B5%81.assets/image-20211123170444733.png)

出现 `container` 高度坍塌的原因：

1. `box1` 设置为浮动，脱离了当前正常流，移动到当前位置的左边。
2. `container` 内失去了 `box1` 的占位，所以高度参考 `box2`，出现了高度坍塌。
   -  `box1` 的包含块不是 `container`，而是根元素 `html`。`container` 自然无法包裹脱离正常流的 `box1`。

#### 解决方式一：BFC

`container` 设置 `overflow：auto` 其内部创建了一个 BFC，根据规则 BFC 的高度计算需要参考 `float` 元素，所以元素会被撑开。

- 只要让 `container` 成为 `box1` 的包含块即可撑开 `container` 的高度。
- 因为 `container` 创建了一个 BFC，此时 `box1` 的包含块就是 `container` 了，所以 `container` 自然被 `box1` 撑开

![image-20211123170431340](images/%E6%AD%A3%E5%B8%B8%E6%B5%81.assets/image-20211123170431340.png)

#### 解决方式二：clear float

`clear` 清除浮动，会让被清除浮动的元素移动到浮动元素的下方。那么我们通过 CSS 创建一个内容为空的伪元素，然后让他清除浮动，就可以解决这个问题：

- 注意这个伪元素必须设置为 `block`，否则变成内联了，无法撑开。
- `::after` 会为选中元素的 **内容的最后** ，添加一个 新元素。在这里其实是对 `container` 容器内 **添加了一个子元素** 。

```css
.container::after {
    content: "";
    display: block; 
    clear: both;
}
```

